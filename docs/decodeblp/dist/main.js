/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./third_party/decoder.js":
/*!********************************!*\
  !*** ./third_party/decoder.js ***!
  \********************************/
/***/ ((module) => {

eval("/*\n Copyright 2011 notmasteryet\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\n// NOTE: This file was edited to match the crude usage of the JPG format by Blizzard for their BLP1 format.\n\nvar JpegImage = (function jpegImage() {\n    \"use strict\";\n    var dctZigZag = new Int32Array([\n        0,\n        1,  8,\n        16,  9,  2,\n        3, 10, 17, 24,\n        32, 25, 18, 11, 4,\n        5, 12, 19, 26, 33, 40,\n        48, 41, 34, 27, 20, 13,  6,\n        7, 14, 21, 28, 35, 42, 49, 56,\n        57, 50, 43, 36, 29, 22, 15,\n        23, 30, 37, 44, 51, 58,\n        59, 52, 45, 38, 31,\n        39, 46, 53, 60,\n        61, 54, 47,\n        55, 62,\n        63\n    ]);\n\n    var dctCos1  =  4017   // cos(pi/16)\n    var dctSin1  =   799   // sin(pi/16)\n    var dctCos3  =  3406   // cos(3*pi/16)\n    var dctSin3  =  2276   // sin(3*pi/16)\n    var dctCos6  =  1567   // cos(6*pi/16)\n    var dctSin6  =  3784   // sin(6*pi/16)\n    var dctSqrt2 =  5793   // sqrt(2)\n    var dctSqrt1d2 = 2896  // sqrt(2) / 2\n\n    function constructor() {\n    }\n\n    function buildHuffmanTable(codeLengths, values) {\n        var k = 0, code = [], i, j, length = 16;\n        while (length > 0 && !codeLengths[length - 1])\n            length--;\n        code.push({children: [], index: 0});\n        var p = code[0], q;\n        for (i = 0; i < length; i++) {\n            for (j = 0; j < codeLengths[i]; j++) {\n                p = code.pop();\n                p.children[p.index] = values[k];\n                while (p.index > 0) {\n                    p = code.pop();\n                }\n                p.index++;\n                code.push(p);\n                while (code.length <= i) {\n                    code.push(q = {children: [], index: 0});\n                    p.children[p.index] = q.children;\n                    p = q;\n                }\n                k++;\n            }\n            if (i + 1 < length) {\n                // p here points to last code\n                code.push(q = {children: [], index: 0});\n                p.children[p.index] = q.children;\n                p = q;\n            }\n        }\n        return code[0].children;\n    }\n\n    function getBlockBufferOffset(component, row, col) {\n        return 64 * ((component.blocksPerLine + 1) * row + col);\n    }\n\n    function decodeScan(data, offset,\n                        frame, components, resetInterval,\n                        spectralStart, spectralEnd,\n                        successivePrev, successive) {\n        var precision = frame.precision;\n        var samplesPerLine = frame.samplesPerLine;\n        var scanLines = frame.scanLines;\n        var mcusPerLine = frame.mcusPerLine;\n        var progressive = frame.progressive;\n        var maxH = frame.maxH, maxV = frame.maxV;\n\n        var startOffset = offset, bitsData = 0, bitsCount = 0;\n\n        function readBit() {\n            if (bitsCount > 0) {\n                bitsCount--;\n                return (bitsData >> bitsCount) & 1;\n            }\n            bitsData = data[offset++];\n            if (bitsData == 0xFF) {\n                var nextByte = data[offset++];\n                if (nextByte) {\n                    throw \"unexpected marker: \" + ((bitsData << 8) | nextByte).toString(16);\n                }\n                // unstuff 0\n            }\n            bitsCount = 7;\n            return bitsData >>> 7;\n        }\n\n        function decodeHuffman(tree) {\n            var node = tree;\n            var bit;\n            while ((bit = readBit()) !== null) {\n                node = node[bit];\n                if (typeof node === 'number')\n                    return node;\n                if (typeof node !== 'object')\n                    throw \"invalid huffman sequence\";\n            }\n            return null;\n        }\n\n        function receive(length) {\n            var n = 0;\n            while (length > 0) {\n                var bit = readBit();\n                if (bit === null) return;\n                n = (n << 1) | bit;\n                length--;\n            }\n            return n;\n        }\n\n        function receiveAndExtend(length) {\n            var n = receive(length);\n            if (n >= 1 << (length - 1))\n                return n;\n            return n + (-1 << length) + 1;\n        }\n\n        function decodeBaseline(component, offset) {\n            var t = decodeHuffman(component.huffmanTableDC);\n            var diff = t === 0 ? 0 : receiveAndExtend(t);\n            component.blockData[offset] = (component.pred += diff);\n            var k = 1;\n            while (k < 64) {\n                var rs = decodeHuffman(component.huffmanTableAC);\n                var s = rs & 15, r = rs >> 4;\n                if (s === 0) {\n                    if (r < 15)\n                        break;\n                    k += 16;\n                    continue;\n                }\n                k += r;\n                var z = dctZigZag[k];\n                component.blockData[offset + z] = receiveAndExtend(s);\n                k++;\n            }\n        }\n\n        function decodeDCFirst(component, offset) {\n            var t = decodeHuffman(component.huffmanTableDC);\n            var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n            component.blockData[offset] = (component.pred += diff);\n        }\n\n        function decodeDCSuccessive(component, offset) {\n            component.blockData[offset] |= readBit() << successive;\n        }\n\n        var eobrun = 0;\n        function decodeACFirst(component, offset) {\n            if (eobrun > 0) {\n                eobrun--;\n                return;\n            }\n            var k = spectralStart, e = spectralEnd;\n            while (k <= e) {\n                var rs = decodeHuffman(component.huffmanTableAC);\n                var s = rs & 15, r = rs >> 4;\n                if (s === 0) {\n                    if (r < 15) {\n                        eobrun = receive(r) + (1 << r) - 1;\n                        break;\n                    }\n                    k += 16;\n                    continue;\n                }\n                k += r;\n                var z = dctZigZag[k];\n                component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);\n                k++;\n            }\n        }\n\n        var successiveACState = 0, successiveACNextValue;\n        function decodeACSuccessive(component, offset) {\n            var k = spectralStart, e = spectralEnd, r = 0;\n            while (k <= e) {\n                var z = dctZigZag[k];\n                switch (successiveACState) {\n                    case 0: // initial state\n                        var rs = decodeHuffman(component.huffmanTableAC);\n                        var s = rs & 15, r = rs >> 4;\n                        if (s === 0) {\n                            if (r < 15) {\n                                eobrun = receive(r) + (1 << r);\n                                successiveACState = 4;\n                            } else {\n                                r = 16;\n                                successiveACState = 1;\n                            }\n                        } else {\n                            if (s !== 1)\n                                throw \"invalid ACn encoding\";\n                            successiveACNextValue = receiveAndExtend(s);\n                            successiveACState = r ? 2 : 3;\n                        }\n                        continue;\n                    case 1: // skipping r zero items\n                    case 2:\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        } else {\n                            r--;\n                            if (r === 0)\n                                successiveACState = successiveACState == 2 ? 3 : 0;\n                        }\n                        break;\n                    case 3: // set value for a zero item\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        } else {\n                            component.blockData[offset + z] = successiveACNextValue << successive;\n                            successiveACState = 0;\n                        }\n                        break;\n                    case 4: // eob\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        }\n                        break;\n                }\n                k++;\n            }\n            if (successiveACState === 4) {\n                eobrun--;\n                if (eobrun === 0)\n                    successiveACState = 0;\n            }\n        }\n\n        function decodeMcu(component, decode, mcu, row, col) {\n            var mcuRow = (mcu / mcusPerLine) | 0;\n            var mcuCol = mcu % mcusPerLine;\n            var blockRow = mcuRow * component.v + row;\n            var blockCol = mcuCol * component.h + col;\n            var offset = getBlockBufferOffset(component, blockRow, blockCol);\n            decode(component, offset);\n        }\n\n        function decodeBlock(component, decode, mcu) {\n            var blockRow = (mcu / component.blocksPerLine) | 0;\n            var blockCol = mcu % component.blocksPerLine;\n            var offset = getBlockBufferOffset(component, blockRow, blockCol);\n            decode(component, offset);\n        }\n\n        var componentsLength = components.length;\n        var component, i, j, k, n;\n        var decodeFn;\n        if (progressive) {\n            if (spectralStart === 0)\n                decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n            else\n                decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n        } else {\n            decodeFn = decodeBaseline;\n        }\n\n        var mcu = 0, marker;\n        var mcuExpected;\n        if (componentsLength == 1) {\n            mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n        } else {\n            mcuExpected = mcusPerLine * frame.mcusPerColumn;\n        }\n        if (!resetInterval) {\n            resetInterval = mcuExpected;\n        }\n\n        var h, v;\n        while (mcu < mcuExpected) {\n            // reset interval stuff\n            for (i = 0; i < componentsLength; i++) {\n                components[i].pred = 0;\n            }\n            eobrun = 0;\n\n            if (componentsLength == 1) {\n                component = components[0];\n                for (n = 0; n < resetInterval; n++) {\n                    decodeBlock(component, decodeFn, mcu);\n                    mcu++;\n                }\n            } else {\n                for (n = 0; n < resetInterval; n++) {\n                    for (i = 0; i < componentsLength; i++) {\n                        component = components[i];\n                        h = component.h;\n                        v = component.v;\n                        for (j = 0; j < v; j++) {\n                            for (k = 0; k < h; k++) {\n                                decodeMcu(component, decodeFn, mcu, j, k);\n                            }\n                        }\n                    }\n                    mcu++;\n                }\n            }\n\n            // find marker\n            bitsCount = 0;\n            marker = (data[offset] << 8) | data[offset + 1];\n            if (marker <= 0xFF00) {\n                throw \"marker was not found\";\n            }\n\n            if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n                offset += 2;\n            } else {\n                break;\n            }\n        }\n\n        return offset - startOffset;\n    }\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(component, blockBufferOffset, p) {\n        var qt = component.quantizationTable;\n        var v0, v1, v2, v3, v4, v5, v6, v7, t;\n        var i;\n\n        // dequant\n        for (i = 0; i < 64; i++) {\n            p[i] = component.blockData[blockBufferOffset + i] * qt[i];\n        }\n\n        // inverse DCT on rows\n        for (i = 0; i < 8; ++i) {\n            var row = 8 * i;\n\n            // check for all-zero AC coefficients\n            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&\n                p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&\n                p[7 + row] == 0) {\n                t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n                p[0 + row] = t;\n                p[1 + row] = t;\n                p[2 + row] = t;\n                p[3 + row] = t;\n                p[4 + row] = t;\n                p[5 + row] = t;\n                p[6 + row] = t;\n                p[7 + row] = t;\n                continue;\n            }\n\n            // stage 4\n            v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n            v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n            v2 = p[2 + row];\n            v3 = p[6 + row];\n            v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n            v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n            v5 = p[3 + row] << 4;\n            v6 = p[5 + row] << 4;\n\n            // stage 3\n            t = (v0 - v1+ 1) >> 1;\n            v0 = (v0 + v1 + 1) >> 1;\n            v1 = t;\n            t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n            v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n            v3 = t;\n            t = (v4 - v6 + 1) >> 1;\n            v4 = (v4 + v6 + 1) >> 1;\n            v6 = t;\n            t = (v7 + v5 + 1) >> 1;\n            v5 = (v7 - v5 + 1) >> 1;\n            v7 = t;\n\n            // stage 2\n            t = (v0 - v3 + 1) >> 1;\n            v0 = (v0 + v3 + 1) >> 1;\n            v3 = t;\n            t = (v1 - v2 + 1) >> 1;\n            v1 = (v1 + v2 + 1) >> 1;\n            v2 = t;\n            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n            v7 = t;\n            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n            v6 = t;\n\n            // stage 1\n            p[0 + row] = v0 + v7;\n            p[7 + row] = v0 - v7;\n            p[1 + row] = v1 + v6;\n            p[6 + row] = v1 - v6;\n            p[2 + row] = v2 + v5;\n            p[5 + row] = v2 - v5;\n            p[3 + row] = v3 + v4;\n            p[4 + row] = v3 - v4;\n        }\n\n        // inverse DCT on columns\n        for (i = 0; i < 8; ++i) {\n            var col = i;\n\n            // check for all-zero AC coefficients\n            if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&\n                p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&\n                p[7*8 + col] == 0) {\n                t = (dctSqrt2 * p[i+0] + 8192) >> 14;\n                p[0*8 + col] = t;\n                p[1*8 + col] = t;\n                p[2*8 + col] = t;\n                p[3*8 + col] = t;\n                p[4*8 + col] = t;\n                p[5*8 + col] = t;\n                p[6*8 + col] = t;\n                p[7*8 + col] = t;\n                continue;\n            }\n\n            // stage 4\n            v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;\n            v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;\n            v2 = p[2*8 + col];\n            v3 = p[6*8 + col];\n            v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;\n            v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;\n            v5 = p[3*8 + col];\n            v6 = p[5*8 + col];\n\n            // stage 3\n            t = (v0 - v1 + 1) >> 1;\n            v0 = (v0 + v1 + 1) >> 1;\n            v1 = t;\n            t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n            v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n            v3 = t;\n            t = (v4 - v6 + 1) >> 1;\n            v4 = (v4 + v6 + 1) >> 1;\n            v6 = t;\n            t = (v7 + v5 + 1) >> 1;\n            v5 = (v7 - v5 + 1) >> 1;\n            v7 = t;\n\n            // stage 2\n            t = (v0 - v3 + 1) >> 1;\n            v0 = (v0 + v3 + 1) >> 1;\n            v3 = t;\n            t = (v1 - v2 + 1) >> 1;\n            v1 = (v1 + v2 + 1) >> 1;\n            v2 = t;\n            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n            v7 = t;\n            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n            v6 = t;\n\n            // stage 1\n            p[0*8 + col] = v0 + v7;\n            p[7*8 + col] = v0 - v7;\n            p[1*8 + col] = v1 + v6;\n            p[6*8 + col] = v1 - v6;\n            p[2*8 + col] = v2 + v5;\n            p[5*8 + col] = v2 - v5;\n            p[3*8 + col] = v3 + v4;\n            p[4*8 + col] = v3 - v4;\n        }\n\n        // convert to 8-bit integers\n        for (i = 0; i < 64; ++i) {\n            var index = blockBufferOffset + i;\n            var q = p[i];\n            q = (q <= -2056) ? 0 : (q >= 2024) ? 255 : (q + 2056) >> 4;\n            component.blockData[index] = q;\n        }\n    }\n\n    function buildComponentData(frame, component) {\n        var lines = [];\n        var blocksPerLine = component.blocksPerLine;\n        var blocksPerColumn = component.blocksPerColumn;\n        var samplesPerLine = blocksPerLine << 3;\n        var computationBuffer = new Int32Array(64);\n\n        var i, j, ll = 0;\n        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n            for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                var offset = getBlockBufferOffset(component, blockRow, blockCol)\n                quantizeAndInverse(component, offset, computationBuffer);\n            }\n        }\n        return component.blockData;\n    }\n\n    function clampToUint8(a) {\n        return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;\n    }\n\n    constructor.prototype = {\n        load: function load(path) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", path, true);\n            xhr.responseType = \"arraybuffer\";\n            xhr.onload = (function() {\n                // TODO catch parse error\n                var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n                this.parse(data);\n                if (this.onload)\n                    this.onload();\n            }).bind(this);\n            xhr.send(null);\n        },\n\n        loadFromBuffer: function loadFromBuffer(arrayBuffer) {\n            this.parse(arrayBuffer);\n            if (this.onload)\n                this.onload();\n        },\n\n        parse: function parse(data) {\n\n            function readUint16() {\n                var value = (data[offset] << 8) | data[offset + 1];\n                offset += 2;\n                return value;\n            }\n\n            function readDataBlock() {\n                var length = readUint16();\n                var array = data.subarray(offset, offset + length - 2);\n                offset += array.length;\n                return array;\n            }\n\n            function prepareComponents(frame) {\n                var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\n                var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\n                for (var i = 0; i < frame.components.length; i++) {\n                    component = frame.components[i];\n                    var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);\n                    var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / frame.maxV);\n                    var blocksPerLineForMcu = mcusPerLine * component.h;\n                    var blocksPerColumnForMcu = mcusPerColumn * component.v;\n\n                    var blocksBufferSize = 64 * blocksPerColumnForMcu\n                        * (blocksPerLineForMcu + 1);\n                    component.blockData = new Int16Array(blocksBufferSize);\n                    component.blocksPerLine = blocksPerLine;\n                    component.blocksPerColumn = blocksPerColumn;\n                }\n                frame.mcusPerLine = mcusPerLine;\n                frame.mcusPerColumn = mcusPerColumn;\n            }\n\n            var offset = 0, length = data.length;\n            var jfif = null;\n            var adobe = null;\n            var pixels = null;\n            var frame, resetInterval;\n            var quantizationTables = [];\n            var huffmanTablesAC = [], huffmanTablesDC = [];\n            var fileMarker = readUint16();\n            if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n                throw \"SOI not found\";\n            }\n\n            fileMarker = readUint16();\n            while (fileMarker != 0xFFD9) { // EOI (End of image)\n                var i, j, l;\n                switch(fileMarker) {\n                    case 0xFFE0: // APP0 (Application Specific)\n                    case 0xFFE1: // APP1\n                    case 0xFFE2: // APP2\n                    case 0xFFE3: // APP3\n                    case 0xFFE4: // APP4\n                    case 0xFFE5: // APP5\n                    case 0xFFE6: // APP6\n                    case 0xFFE7: // APP7\n                    case 0xFFE8: // APP8\n                    case 0xFFE9: // APP9\n                    case 0xFFEA: // APP10\n                    case 0xFFEB: // APP11\n                    case 0xFFEC: // APP12\n                    case 0xFFED: // APP13\n                    case 0xFFEE: // APP14\n                    case 0xFFEF: // APP15\n                    case 0xFFFE: // COM (Comment)\n                        var appData = readDataBlock();\n\n                        if (fileMarker === 0xFFE0) {\n                            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                                jfif = {\n                                    version: { major: appData[5], minor: appData[6] },\n                                    densityUnits: appData[7],\n                                    xDensity: (appData[8] << 8) | appData[9],\n                                    yDensity: (appData[10] << 8) | appData[11],\n                                    thumbWidth: appData[12],\n                                    thumbHeight: appData[13],\n                                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                                };\n                            }\n                        }\n                        // TODO APP1 - Exif\n                        if (fileMarker === 0xFFEE) {\n                            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                                adobe = {\n                                    version: appData[6],\n                                    flags0: (appData[7] << 8) | appData[8],\n                                    flags1: (appData[9] << 8) | appData[10],\n                                    transformCode: appData[11]\n                                };\n                            }\n                        }\n                        break;\n\n                    case 0xFFDB: // DQT (Define Quantization Tables)\n                        var quantizationTablesLength = readUint16();\n                        var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n                        while (offset < quantizationTablesEnd) {\n                            var quantizationTableSpec = data[offset++];\n                            var tableData = new Int32Array(64);\n                            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                                for (j = 0; j < 64; j++) {\n                                    var z = dctZigZag[j];\n                                    tableData[z] = data[offset++];\n                                }\n                            } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                                for (j = 0; j < 64; j++) {\n                                    var z = dctZigZag[j];\n                                    tableData[z] = readUint16();\n                                }\n                            } else\n                                throw \"DQT: invalid table spec\";\n                            quantizationTables[quantizationTableSpec & 15] = tableData;\n                        }\n                        break;\n\n                    case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n                    case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n                    case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n                        if (frame) {\n                            throw \"Only single frame JPEGs supported\";\n                        }\n                        readUint16(); // skip data length\n                        frame = {};\n                        frame.extended = (fileMarker === 0xFFC1);\n                        frame.progressive = (fileMarker === 0xFFC2);\n                        frame.precision = data[offset++];\n                        frame.scanLines = readUint16();\n                        frame.samplesPerLine = readUint16();\n                        frame.components = [];\n                        frame.componentIds = {};\n                        var componentsCount = data[offset++], componentId;\n                        var maxH = 0, maxV = 0;\n                        for (i = 0; i < componentsCount; i++) {\n                            componentId = data[offset];\n                            var h = data[offset + 1] >> 4;\n                            var v = data[offset + 1] & 15;\n                            if (maxH < h) maxH = h;\n                            if (maxV < v) maxV = v;\n                            var qId = data[offset + 2];\n                            var l = frame.components.push({\n                                h: h,\n                                v: v,\n                                quantizationTable: quantizationTables[qId]\n                            });\n                            frame.componentIds[componentId] = l - 1;\n                            offset += 3;\n                        }\n                        frame.maxH = maxH;\n                        frame.maxV = maxV;\n                        prepareComponents(frame);\n                        break;\n\n                    case 0xFFC4: // DHT (Define Huffman Tables)\n                        var huffmanLength = readUint16();\n                        for (i = 2; i < huffmanLength;) {\n                            var huffmanTableSpec = data[offset++];\n                            var codeLengths = new Uint8Array(16);\n                            var codeLengthSum = 0;\n                            for (j = 0; j < 16; j++, offset++)\n                                codeLengthSum += (codeLengths[j] = data[offset]);\n                            var huffmanValues = new Uint8Array(codeLengthSum);\n                            for (j = 0; j < codeLengthSum; j++, offset++)\n                                huffmanValues[j] = data[offset];\n                            i += 17 + codeLengthSum;\n\n                            ((huffmanTableSpec >> 4) === 0 ?\n                                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                                buildHuffmanTable(codeLengths, huffmanValues);\n                        }\n                        break;\n\n                    case 0xFFDD: // DRI (Define Restart Interval)\n                        readUint16(); // skip data length\n                        resetInterval = readUint16();\n                        break;\n\n                    case 0xFFDA: // SOS (Start of Scan)\n                        var scanLength = readUint16();\n                        var selectorsCount = data[offset++];\n                        var components = [], component;\n                        for (i = 0; i < selectorsCount; i++) {\n                            var componentIndex = frame.componentIds[data[offset++]];\n                            component = frame.components[componentIndex];\n                            var tableSpec = data[offset++];\n                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n                            components.push(component);\n                        }\n                        var spectralStart = data[offset++];\n                        var spectralEnd = data[offset++];\n                        var successiveApproximation = data[offset++];\n                        var processed = decodeScan(data, offset,\n                            frame, components, resetInterval,\n                            spectralStart, spectralEnd,\n                            successiveApproximation >> 4, successiveApproximation & 15);\n                        offset += processed;\n                        break;\n                    default:\n                        if (data[offset - 3] == 0xFF &&\n                            data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n                            // could be incorrect encoding -- last 0xFF byte of the previous\n                            // block was eaten by the encoder\n                            offset -= 3;\n                            break;\n                        }\n                        throw \"unknown JPEG marker \" + fileMarker.toString(16);\n                }\n                fileMarker = readUint16();\n            }\n\n            this.width = frame.samplesPerLine;\n            this.height = frame.scanLines;\n            this.jfif = jfif;\n            this.adobe = adobe;\n            this.components = [];\n            for (var i = 0; i < frame.components.length; i++) {\n                var component = frame.components[i];\n                this.components.push({\n                    output: buildComponentData(frame, component),\n                    scaleX: component.h / frame.maxH,\n                    scaleY: component.v / frame.maxV,\n                    blocksPerLine: component.blocksPerLine,\n                    blocksPerColumn: component.blocksPerColumn\n                });\n            }\n        },\n\n        getData: function getData(imageData, width, height) {\n            var scaleX = this.width / width, scaleY = this.height / height;\n\n            var component, componentScaleX, componentScaleY;\n            var x, y, i;\n            var offset = 0;\n            var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n            var colorTransform;\n            var numComponents = this.components.length;\n            var dataLength = width * height * numComponents;\n            //var data = new Uint8Array(dataLength);\n            var data = imageData.data;\n            var componentLine;\n\n            // lineData is reused for all components. Assume first component is\n            // the biggest\n            var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *\n                this.components[0].blocksPerColumn * 8);\n\n            // First construct image data ...\n            for (i = 0; i < numComponents; i++) {\n                component = this.components[i < 3 ? 2 - i : i];\n                var blocksPerLine = component.blocksPerLine;\n                var blocksPerColumn = component.blocksPerColumn;\n                var samplesPerLine = blocksPerLine << 3;\n\n                var j, k, ll = 0;\n                var lineOffset = 0;\n                for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                    var scanLine = blockRow << 3;\n                    for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                        var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                        var offset = 0, sample = blockCol << 3;\n                        for (j = 0; j < 8; j++) {\n                            var lineOffset = (scanLine + j) * samplesPerLine;\n                            for (k = 0; k < 8; k++) {\n                                lineData[lineOffset + sample + k] =\n                                    component.output[bufferOffset + offset++];\n                            }\n                        }\n                    }\n                }\n\n                componentScaleX = component.scaleX * scaleX;\n                componentScaleY = component.scaleY * scaleY;\n                offset = i;\n\n                var cx, cy;\n                var index;\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        cy = 0 | (y * componentScaleY);\n                        cx = 0 | (x * componentScaleX);\n                        index = cy * samplesPerLine + cx;\n                        data[offset] = lineData[index];\n                        offset += numComponents;\n                    }\n                }\n            }\n\n          /*\n           // ... then transform colors, if necessary\n           switch (numComponents) {\n           case 1: case 2: break;\n           // no color conversion for one or two compoenents\n\n           case 3:\n           // The default transform for three components is true\n           colorTransform = true;\n           // The adobe transform marker overrides any previous setting\n           if (this.adobe && this.adobe.transformCode)\n           colorTransform = true;\n           else if (typeof this.colorTransform !== 'undefined')\n           colorTransform = !!this.colorTransform;\n\n           if (colorTransform) {\n           for (i = 0; i < dataLength; i += numComponents) {\n           Y  = data[i    ];\n           Cb = data[i + 1];\n           Cr = data[i + 2];\n\n           R = clampToUint8(Y - 179.456 + 1.402 * Cr);\n           G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);\n           B = clampToUint8(Y - 226.816 + 1.772 * Cb);\n\n           data[i    ] = R;\n           data[i + 1] = G;\n           data[i + 2] = B;\n           }\n           }\n           break;\n           case 4:\n           console.log(this.colorTransform);\n           if (!this.adobe)\n           throw 'Unsupported color mode (4 components)';\n           // The default transform for four components is false\n           colorTransform = false;\n           // The adobe transform marker overrides any previous setting\n           if (this.adobe && this.adobe.transformCode)\n           colorTransform = true;\n           else if (typeof this.colorTransform !== 'undefined')\n           colorTransform = !!this.colorTransform;\n\n           if (colorTransform) {\n           for (i = 0; i < dataLength; i += numComponents) {\n           Y  = data[i];\n           Cb = data[i + 1];\n           Cr = data[i + 2];\n\n           C = clampToUint8(434.456 - Y - 1.402 * Cr);\n           M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);\n           Y = clampToUint8(481.816 - Y - 1.772 * Cb);\n\n           data[i    ] = C;\n           data[i + 1] = M;\n           data[i + 2] = Y;\n           // K is unchanged\n           }\n           }\n           break;\n           default:\n           throw 'Unsupported color mode';\n           }\n           */\n            return data;\n        },\n        copyToImageData: function copyToImageData(imageData) {\n            var width = imageData.width, height = imageData.height;\n            var imageDataBytes = width * height * 4;\n            var imageDataArray = imageData.data;\n            var data = this.getData(width, height);\n            var i = 0, j = 0, k0, k1;\n            var Y, K, C, M, R, G, B;\n            switch (this.components.length) {\n                case 1:\n                    while (j < imageDataBytes) {\n                        Y = data[i++];\n\n                        imageDataArray[j++] = Y;\n                        imageDataArray[j++] = Y;\n                        imageDataArray[j++] = Y;\n                        imageDataArray[j++] = 255;\n                    }\n                    break;\n                case 3:\n                    while (j < imageDataBytes) {\n                        R = data[i++];\n                        G = data[i++];\n                        B = data[i++];\n\n                        imageDataArray[j++] = R;\n                        imageDataArray[j++] = G;\n                        imageDataArray[j++] = B;\n                        imageDataArray[j++] = 255;\n                    }\n                    break;\n                case 4:\n                    while (j < imageDataBytes) {\n                        C = data[i++];\n                        M = data[i++];\n                        Y = data[i++];\n                        K = data[i++];\n\n                        k0 = 255 - K;\n                        k1 = k0 / 255;\n\n\n                        R = clampToUint8(k0 - C * k1);\n                        G = clampToUint8(k0 - M * k1);\n                        B = clampToUint8(k0 - Y * k1);\n\n                        imageDataArray[j++] = R;\n                        imageDataArray[j++] = G;\n                        imageDataArray[j++] = B;\n                        imageDataArray[j++] = 255;\n                    }\n                    break;\n                default:\n                    throw 'Unsupported color mode';\n            }\n        }\n    };\n\n    return constructor;\n})();\n\nmodule.exports = function decode (data) {\n    const jpegImage = new JpegImage();\n\n    jpegImage.loadFromBuffer(data);\n\n    var imageData;\n    if (typeof ImageData !== 'undefined') {\n        imageData = new ImageData(jpegImage.width, jpegImage.height);\n    } else {\n        imageData = {\n            width: jpegImage.width,\n            height: jpegImage.height,\n            data: new Uint8ClampedArray(jpegImage.width * jpegImage.height * 4)\n        };\n    }\n    jpegImage.getData(imageData, jpegImage.width, jpegImage.height);\n\n    return imageData;\n};\n\n\n//# sourceURL=webpack://war3-model/./third_party/decoder.js?");

/***/ }),

/***/ "./blp/blpimage.ts":
/*!*************************!*\
  !*** ./blp/blpimage.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLPContent: () => (/* binding */ BLPContent),\n/* harmony export */   BLPType: () => (/* binding */ BLPType)\n/* harmony export */ });\nvar BLPType;\n(function (BLPType) {\n    BLPType[BLPType[\"BLP0\"] = 0] = \"BLP0\";\n    BLPType[BLPType[\"BLP1\"] = 1] = \"BLP1\";\n    BLPType[BLPType[\"BLP2\"] = 2] = \"BLP2\";\n})(BLPType || (BLPType = {}));\nvar BLPContent;\n(function (BLPContent) {\n    BLPContent[BLPContent[\"JPEG\"] = 0] = \"JPEG\";\n    BLPContent[BLPContent[\"Direct\"] = 1] = \"Direct\";\n})(BLPContent || (BLPContent = {}));\n\n\n//# sourceURL=webpack://war3-model/./blp/blpimage.ts?");

/***/ }),

/***/ "./blp/decode.ts":
/*!***********************!*\
  !*** ./blp/decode.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   getImageData: () => (/* binding */ getImageData)\n/* harmony export */ });\n/* harmony import */ var _third_party_decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../third_party/decoder */ \"./third_party/decoder.js\");\n/* harmony import */ var _third_party_decoder__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_third_party_decoder__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _blpimage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blpimage */ \"./blp/blpimage.ts\");\n\n\nfunction keyword(view, offset) {\n    return String.fromCharCode(view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3));\n}\nfunction uint32(view, offset) {\n    return view.getUint32(offset * 4, true);\n}\nfunction bitVal(data, bitCount, index) {\n    // only 1, 4 or 8 bits\n    var byte = data[Math.floor(index * bitCount / 8)], valsPerByte = 8 / bitCount;\n    return (byte >> (valsPerByte - index % valsPerByte - 1)) & ((1 << bitCount) - 1);\n}\n// node.js have no native ImageData\nfunction createImageData(width, height) {\n    if (typeof ImageData !== 'undefined') {\n        return new ImageData(width, height);\n    }\n    else {\n        return {\n            width: width,\n            height: height,\n            data: new Uint8ClampedArray(width * height * 4),\n            colorSpace: 'srgb'\n        };\n    }\n}\nfunction decode(arrayBuffer) {\n    var view = new DataView(arrayBuffer);\n    var image = {\n        type: _blpimage__WEBPACK_IMPORTED_MODULE_1__.BLPType.BLP1,\n        width: 0,\n        height: 0,\n        content: _blpimage__WEBPACK_IMPORTED_MODULE_1__.BLPContent.JPEG,\n        alphaBits: 0,\n        mipmaps: [],\n        data: arrayBuffer,\n    };\n    var type = keyword(view, 0);\n    if (type === 'BLP0' || type === 'BLP2') {\n        throw new Error('BLP0/BLP2 not supported');\n    }\n    if (type !== 'BLP1') {\n        throw new Error('Not a blp image');\n    }\n    image.content = uint32(view, 1);\n    if (image.content !== _blpimage__WEBPACK_IMPORTED_MODULE_1__.BLPContent.JPEG && image.content !== _blpimage__WEBPACK_IMPORTED_MODULE_1__.BLPContent.Direct) {\n        throw new Error('Unknown BLP content');\n    }\n    image.alphaBits = uint32(view, 2);\n    image.width = uint32(view, 3);\n    image.height = uint32(view, 4);\n    for (var i = 0; i < 16; ++i) {\n        var mipmap = {\n            offset: uint32(view, 7 + i),\n            size: uint32(view, 7 + 16 + i)\n        };\n        if (mipmap.size > 0) {\n            image.mipmaps.push(mipmap);\n        }\n        else {\n            break;\n        }\n    }\n    return image;\n}\nfunction getImageData(blp, mipmapLevel) {\n    var view = new DataView(blp.data), uint8Data = new Uint8Array(blp.data), mipmap = blp.mipmaps[mipmapLevel];\n    if (blp.content === _blpimage__WEBPACK_IMPORTED_MODULE_1__.BLPContent.JPEG) {\n        var headerSize = uint32(view, 39), data = new Uint8Array(headerSize + mipmap.size);\n        data.set(uint8Data.subarray(40 * 4, 40 * 4 + headerSize));\n        data.set(uint8Data.subarray(mipmap.offset, mipmap.offset + mipmap.size), headerSize);\n        return _third_party_decoder__WEBPACK_IMPORTED_MODULE_0___default()(data);\n    }\n    else {\n        var palette = new Uint8Array(blp.data, 39 * 4, 256 * 4), width = blp.width / (1 << mipmapLevel), height = blp.height / (1 << mipmapLevel), size = width * height, alphaData = new Uint8Array(blp.data, mipmap.offset + size, Math.ceil(size * blp.alphaBits / 8)), imageData = createImageData(width, height), valPerAlphaBit = 255 / ((1 << blp.alphaBits) - 1);\n        for (var i = 0; i < size; ++i) {\n            var paletteIndex = view.getUint8(mipmap.offset + i) * 4;\n            // BGRA order\n            imageData.data[i * 4] = palette[paletteIndex + 2];\n            imageData.data[i * 4 + 1] = palette[paletteIndex + 1];\n            imageData.data[i * 4 + 2] = palette[paletteIndex];\n            if (blp.alphaBits > 0) {\n                imageData.data[i * 4 + 3] = bitVal(alphaData, blp.alphaBits, i) * valPerAlphaBit;\n            }\n            else {\n                imageData.data[i * 4 + 3] = 255;\n            }\n        }\n        return imageData;\n    }\n}\n\n\n//# sourceURL=webpack://war3-model/./blp/decode.ts?");

/***/ }),

/***/ "./docs/decodeblp/decodeblp.ts":
/*!*************************************!*\
  !*** ./docs/decodeblp/decodeblp.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _blp_decode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../blp/decode */ \"./blp/decode.ts\");\n\n\ndocument.addEventListener('DOMContentLoaded', function init() {\n    var container = document.querySelector('.container');\n    var preview = document.querySelector('.preview');\n    var label = document.querySelector('.label');\n    var dropTarget;\n    container.addEventListener('dragenter', function onDragEnter(event) {\n        dropTarget = event.target;\n        container.classList.add('container_drag');\n        event.preventDefault();\n    });\n    container.addEventListener('dragleave', function onDragLeave(event) {\n        if (event.target === dropTarget) {\n            container.classList.remove('container_drag');\n        }\n    });\n    container.addEventListener('dragover', function onDragLeave(event) {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = 'copy';\n    });\n    container.addEventListener('drop', function onDrop(event) {\n        event.preventDefault();\n        container.classList.remove('container_drag');\n        var file = event.dataTransfer.files && event.dataTransfer.files[0];\n        if (!file) {\n            return;\n        }\n        var reader = new FileReader();\n        reader.onload = function () {\n            try {\n                var blp = (0,_blp_decode__WEBPACK_IMPORTED_MODULE_0__.decode)(reader.result);\n                console.log(blp);\n                clearPreview();\n                container.classList.add('container_hidden');\n                for (var i = 0; i < blp.mipmaps.length; ++i) {\n                    var imageData = (0,_blp_decode__WEBPACK_IMPORTED_MODULE_0__.getImageData)(blp, i);\n                    var canvas = document.createElement('canvas');\n                    canvas.width = imageData.width;\n                    canvas.height = imageData.height;\n                    var ctx = canvas.getContext('2d');\n                    ctx.putImageData(imageData, 0, 0);\n                    var previewItem = document.createElement('div');\n                    previewItem.className = 'preview-item';\n                    var previewLabel = document.createElement('div');\n                    previewLabel.className = 'preview-item__label';\n                    previewLabel.textContent = \"\".concat(imageData.width, \"x\").concat(imageData.height);\n                    previewItem.appendChild(canvas);\n                    previewItem.appendChild(previewLabel);\n                    preview.appendChild(previewItem);\n                }\n            }\n            catch (err) {\n                showError(err);\n            }\n        };\n        reader.readAsArrayBuffer(file);\n    });\n    function clearPreview() {\n        preview.innerHTML = '';\n    }\n    function showError(err) {\n        clearPreview();\n        container.classList.remove('container_hidden');\n        label.textContent = err;\n        console.error(err);\n    }\n});\n\n\n//# sourceURL=webpack://war3-model/./docs/decodeblp/decodeblp.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./docs/decodeblp/decodeblp.ts");
/******/ 	
/******/ })()
;