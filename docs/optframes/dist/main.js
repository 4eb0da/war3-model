/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./docs/common/shim.ts":
/*!*****************************!*\
  !*** ./docs/common/shim.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nif (!Float32Array.prototype.reverse) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    Float32Array.prototype.reverse = Array.prototype.reverse;\n}\n\n\n\n//# sourceURL=webpack://war3-model/./docs/common/shim.ts?");

/***/ }),

/***/ "./docs/optframes/optframes.ts":
/*!*************************************!*\
  !*** ./docs/optframes/optframes.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mdl_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mdl/parse */ \"./mdl/parse.ts\");\n/* harmony import */ var _mdx_parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mdx/parse */ \"./mdx/parse.ts\");\n/* harmony import */ var _mdl_generate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mdl/generate */ \"./mdl/generate.ts\");\n/* harmony import */ var _mdx_generate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mdx/generate */ \"./mdx/generate.ts\");\n/* harmony import */ var _common_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/shim */ \"./docs/common/shim.ts\");\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', function init() {\n    var container = document.querySelector('.container');\n    var saveMDL = document.querySelector('.save[data-type=\"mdl\"]');\n    var saveMDX = document.querySelector('.save[data-type=\"mdx\"]');\n    var label = document.querySelector('.label');\n    var log = document.querySelector('.log');\n    var dropTarget;\n    var model;\n    var cleanedName;\n    container.addEventListener('dragenter', function onDragEnter(event) {\n        dropTarget = event.target;\n        container.classList.add('container_drag');\n        event.preventDefault();\n    });\n    container.addEventListener('dragleave', function onDragLeave(event) {\n        if (event.target === dropTarget) {\n            container.classList.remove('container_drag');\n        }\n    });\n    container.addEventListener('dragover', function onDragLeave(event) {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = 'copy';\n    });\n    container.addEventListener('drop', function onDrop(event) {\n        event.preventDefault();\n        container.classList.remove('container_drag');\n        var file = event.dataTransfer.files && event.dataTransfer.files[0];\n        if (!file) {\n            return;\n        }\n        var reader = new FileReader();\n        var isMDX = file.name.indexOf('.mdx') > -1;\n        cleanedName = file.name.replace(/\\.[^.]+$/, '');\n        reader.onload = function () {\n            try {\n                if (isMDX) {\n                    model = (0,_mdx_parse__WEBPACK_IMPORTED_MODULE_1__.parse)(reader.result);\n                }\n                else {\n                    model = (0,_mdl_parse__WEBPACK_IMPORTED_MODULE_0__.parse)(reader.result);\n                }\n            }\n            catch (err) {\n                showError(err);\n                return;\n            }\n            processModel();\n        };\n        if (isMDX) {\n            reader.readAsArrayBuffer(file);\n        }\n        else {\n            reader.readAsText(file);\n        }\n    });\n    [saveMDL, saveMDX].forEach(function (button) {\n        button.addEventListener('click', function save(event) {\n            event.preventDefault();\n            var res;\n            var isMDL = button.getAttribute('data-type') === 'mdl';\n            if (isMDL) {\n                res = new Blob([(0,_mdl_generate__WEBPACK_IMPORTED_MODULE_2__.generate)(model)], { type: 'octet/stream' });\n            }\n            else {\n                res = new Blob([(0,_mdx_generate__WEBPACK_IMPORTED_MODULE_3__.generate)(model)], { type: 'octet/stream' });\n            }\n            var link = document.createElement('a');\n            link.style.display = 'none';\n            document.body.appendChild(link);\n            link.href = URL.createObjectURL(res);\n            link.download = cleanedName + (isMDL ? '.mdl' : '.mdx');\n            link.click();\n            URL.revokeObjectURL(link.href);\n            document.body.removeChild(link);\n        });\n    });\n    function clearLog() {\n        log.innerHTML = '';\n    }\n    function logStr(str) {\n        var p = document.createElement('p');\n        p.textContent = str;\n        log.appendChild(p);\n    }\n    function processModel() {\n        clearLog();\n        logStr('Optimization is lossy, make sure to test result models');\n        var totalKeys = 0, cleanedKeys = 0;\n        var isSameKey = function (keyframe0, keyframe1) {\n            for (var i = 0; i < keyframe0.Vector.length; ++i) {\n                if (keyframe0.Vector[i] !== keyframe1.Vector[i]) {\n                    return false;\n                }\n            }\n            if (keyframe0.InTan) {\n                for (var i = 0; i < keyframe0.InTan.length; ++i) {\n                    if (keyframe0.InTan[i] !== keyframe1.InTan[i]) {\n                        return false;\n                    }\n                }\n                for (var i = 0; i < keyframe0.OutTan.length; ++i) {\n                    if (keyframe0.OutTan[i] !== keyframe1.OutTan[i]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        var processKeys = function (obj, key) {\n            var animVector = obj[key];\n            var sequences = model.Sequences;\n            var globalSequences = model.GlobalSequences;\n            if (!animVector || !animVector.Keys) {\n                return;\n            }\n            totalKeys += animVector.Keys.length;\n            var newKeys = [];\n            var processAnim = function (from, to) {\n                var keys = [];\n                for (var _i = 0, _a = animVector.Keys; _i < _a.length; _i++) {\n                    var keyframe = _a[_i];\n                    if (keyframe.Frame >= from && keyframe.Frame <= to) {\n                        keys.push(keyframe);\n                    }\n                }\n                var prevKey = null;\n                var filtered = [];\n                for (var i = 0; i < keys.length; ++i) {\n                    if (!prevKey) {\n                        prevKey = keys[i];\n                        filtered.push(keys[i]);\n                    }\n                    else {\n                        if (!(isSameKey(keys[i], prevKey) &&\n                            (i + 1 === keys.length || isSameKey(keys[i], keys[i + 1])))) {\n                            filtered.push(keys[i]);\n                        }\n                        prevKey = keys[i];\n                    }\n                }\n                newKeys = newKeys.concat(filtered);\n            };\n            if (animVector.GlobalSeqId !== null) {\n                processAnim(0, globalSequences[animVector.GlobalSeqId]);\n            }\n            else {\n                for (var _i = 0, sequences_1 = sequences; _i < sequences_1.length; _i++) {\n                    var anim = sequences_1[_i];\n                    processAnim(anim.Interval[0], anim.Interval[1]);\n                }\n            }\n            cleanedKeys += animVector.Keys.length - newKeys.length;\n            animVector.Keys = newKeys;\n        };\n        for (var _i = 0, _a = model.Nodes; _i < _a.length; _i++) {\n            var node = _a[_i];\n            processKeys(node, 'Translation');\n            processKeys(node, 'Rotation');\n            processKeys(node, 'Scaling');\n            processKeys(node, 'Visibility');\n            processKeys(node, 'EmissionRate');\n            processKeys(node, 'Gravity');\n            processKeys(node, 'Latitude');\n            processKeys(node, 'LifeSpan');\n            processKeys(node, 'InitVelocity');\n            processKeys(node, 'Speed');\n            processKeys(node, 'Variation');\n            processKeys(node, 'Width');\n            processKeys(node, 'Length');\n            processKeys(node, 'AttenuationStart');\n            processKeys(node, 'AttenuationEnd');\n            processKeys(node, 'Color');\n            processKeys(node, 'Intensity');\n            processKeys(node, 'AmbIntensity');\n            processKeys(node, 'AmbColor');\n            processKeys(node, 'HeightAbove');\n            processKeys(node, 'HeightBelow');\n            processKeys(node, 'Alpha');\n            processKeys(node, 'TextureSlot');\n        }\n        for (var _b = 0, _c = model.Cameras; _b < _c.length; _b++) {\n            var camera = _c[_b];\n            processKeys(camera, 'TargetTranslation');\n            processKeys(camera, 'Translation');\n            processKeys(camera, 'Rotation');\n        }\n        for (var _d = 0, _e = model.TextureAnims; _d < _e.length; _d++) {\n            var anim = _e[_d];\n            processKeys(anim, 'Translation');\n            processKeys(anim, 'Rotation');\n            processKeys(anim, 'Scaling');\n        }\n        for (var _f = 0, _g = model.Materials; _f < _g.length; _f++) {\n            var material = _g[_f];\n            for (var _h = 0, _j = material.Layers; _h < _j.length; _h++) {\n                var layer = _j[_h];\n                processKeys(layer, 'TextureID');\n                processKeys(layer, 'Alpha');\n            }\n        }\n        logStr(cleanedKeys + '/' + totalKeys + ' frames removed');\n        container.classList.add('container_with-data');\n    }\n    function showError(err) {\n        container.classList.remove('container_with-data');\n        label.textContent = err;\n    }\n});\n\n\n//# sourceURL=webpack://war3-model/./docs/optframes/optframes.ts?");

/***/ }),

/***/ "./mdl/generate.ts":
/*!*************************!*\
  !*** ./mdl/generate.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model */ \"./model.ts\");\n/* harmony import */ var _renderer_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/util */ \"./renderer/util.ts\");\n\n\nvar FLOAT_PRESICION = 6;\nvar EPSILON = 1e-6;\nfunction isNotEmptyVec3(vec, val) {\n    if (val === void 0) { val = 0; }\n    return Math.abs(vec[0] - val) > EPSILON ||\n        Math.abs(vec[1] - val) > EPSILON ||\n        Math.abs(vec[2] - val) > EPSILON;\n}\nfunction generateTab(tabSize) {\n    if (tabSize === void 0) { tabSize = 1; }\n    if (tabSize === 0) {\n        return '';\n    }\n    var res = '\\t';\n    for (var i = 1; i < tabSize; ++i) {\n        res += '\\t';\n    }\n    return res;\n}\nfunction generateWrappedString(val) {\n    return \"\\\"\".concat(val, \"\\\"\");\n}\nfunction generateWrappedStringOrNumber(val) {\n    if (typeof val === 'number') {\n        return String(val);\n    }\n    return generateWrappedString(val);\n}\nfunction generateBlockStart(blockName, subInfo, tabSize) {\n    if (subInfo === void 0) { subInfo = null; }\n    if (tabSize === void 0) { tabSize = 0; }\n    return generateTab(tabSize) +\n        blockName + ' ' +\n        (subInfo !== null ? generateWrappedStringOrNumber(subInfo) + ' ' : '') +\n        '{\\n';\n}\nfunction generateBlockEnd(tabSize) {\n    if (tabSize === void 0) { tabSize = 0; }\n    return generateTab(tabSize) + '}\\n';\n}\nvar trailingZeroRegExp = /(\\..+?)0+$/;\nvar trailingZeroRegExp2 = /\\.0+$/;\nvar negativeZeroRegExp = /^-0$/;\nfunction generateNumber(val) {\n    return val.toFixed(FLOAT_PRESICION)\n        .replace(trailingZeroRegExp, '$1')\n        .replace(trailingZeroRegExp2, '')\n        .replace(negativeZeroRegExp, '0');\n}\nfunction generateArray(arr, reverse) {\n    if (reverse === void 0) { reverse = false; }\n    var middle = '';\n    if (reverse) {\n        for (var i = arr.length - 1; i >= 0; --i) {\n            if (i < arr.length - 1) {\n                middle += ', ';\n            }\n            middle += generateNumber(arr[i]);\n        }\n    }\n    else {\n        for (var i = 0; i < arr.length; ++i) {\n            if (i > 0) {\n                middle += ', ';\n            }\n            middle += generateNumber(arr[i]);\n        }\n    }\n    return '{ ' + middle + ' }';\n}\nfunction generateUIntArray(arr) {\n    var middle = '';\n    for (var i = 0; i < arr.length; ++i) {\n        if (i > 0) {\n            middle += ', ';\n        }\n        middle += String(arr[i]);\n    }\n    return '{ ' + middle + ' }';\n}\nfunction generateStatic(isStatic) {\n    return isStatic ? 'static ' : '';\n}\nfunction generateProp(name, val, isStatic, tabSize) {\n    if (tabSize === void 0) { tabSize = 1; }\n    return \"\".concat(generateTab(tabSize) + generateStatic(isStatic) + name, \" \").concat(val, \",\\n\");\n}\nfunction generateIntProp(name, val, isStatic, tabSize) {\n    if (isStatic === void 0) { isStatic = null; }\n    if (tabSize === void 0) { tabSize = 1; }\n    return generateProp(name, String(val), isStatic, tabSize);\n}\nfunction generateFloatProp(name, val, isStatic, tabSize) {\n    if (isStatic === void 0) { isStatic = null; }\n    if (tabSize === void 0) { tabSize = 1; }\n    return generateProp(name, generateNumber(val), isStatic, tabSize);\n}\nfunction generateStringProp(name, val, isStatic, tabSize) {\n    if (isStatic === void 0) { isStatic = null; }\n    if (tabSize === void 0) { tabSize = 1; }\n    return generateProp(name, val, isStatic, tabSize);\n}\nfunction generateWrappedStringProp(name, val, isStatic, tabSize) {\n    if (isStatic === void 0) { isStatic = null; }\n    if (tabSize === void 0) { tabSize = 1; }\n    return generateProp(name, generateWrappedString(val), isStatic, tabSize);\n}\nfunction generateFloatArrayProp(name, val, isStatic, tabSize) {\n    if (isStatic === void 0) { isStatic = null; }\n    if (tabSize === void 0) { tabSize = 1; }\n    return generateProp(name, generateArray(val), isStatic, tabSize);\n}\nfunction generateUIntArrayProp(name, val, isStatic, tabSize) {\n    if (isStatic === void 0) { isStatic = null; }\n    if (tabSize === void 0) { tabSize = 1; }\n    return generateProp(name, generateUIntArray(val), isStatic, tabSize);\n}\nfunction generateBooleanProp(name, tabSize) {\n    if (tabSize === void 0) { tabSize = 1; }\n    return generateTab(tabSize) + name + ',\\n';\n}\nfunction generateIntPropIfNotEmpty(name, val, defaultVal, isStatic, tabSize) {\n    if (defaultVal === void 0) { defaultVal = 0; }\n    if (isStatic === void 0) { isStatic = null; }\n    if (tabSize === void 0) { tabSize = 1; }\n    if (val !== defaultVal && val !== null && val !== undefined) {\n        return generateIntProp(name, val, isStatic, tabSize);\n    }\n    return '';\n}\nfunction generateFloatPropIfNotEmpty(name, val, defaultVal, isStatic, tabSize) {\n    if (defaultVal === void 0) { defaultVal = 0; }\n    if (isStatic === void 0) { isStatic = null; }\n    if (tabSize === void 0) { tabSize = 1; }\n    if (Math.abs(val - defaultVal) > EPSILON) {\n        return generateFloatProp(name, val, isStatic, tabSize);\n    }\n    return '';\n}\nfunction generateLineType(lineType) {\n    switch (lineType) {\n        case _model__WEBPACK_IMPORTED_MODULE_0__.LineType.DontInterp:\n            return 'DontInterp';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Linear:\n            return 'Linear';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Bezier:\n            return 'Bezier';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Hermite:\n            return 'Hermite';\n    }\n    return '';\n}\nfunction generateAnimKeyFrame(key, tabSize, reverse) {\n    if (tabSize === void 0) { tabSize = 2; }\n    if (reverse === void 0) { reverse = false; }\n    var res = generateTab(tabSize) + key.Frame + ': ' +\n        (key.Vector.length === 1 ? generateNumber(key.Vector[0]) : generateArray(key.Vector, reverse)) + ',\\n';\n    if (key.InTan /* or OutTan */) {\n        res += generateTab(tabSize + 1) + 'InTan ' +\n            (key.InTan.length === 1 ? generateNumber(key.InTan[0]) : generateArray(key.InTan, reverse)) + ',\\n';\n        res += generateTab(tabSize + 1) + 'OutTan ' +\n            (key.OutTan.length === 1 ? generateNumber(key.OutTan[0]) : generateArray(key.OutTan, reverse)) + ',\\n';\n    }\n    return res;\n}\nfunction generateAnimVectorProp(name, val, defaultVal, tabSize, reverse) {\n    if (defaultVal === void 0) { defaultVal = 0; }\n    if (tabSize === void 0) { tabSize = 1; }\n    if (reverse === void 0) { reverse = false; }\n    if (val === null || val === undefined) {\n        return '';\n    }\n    if (typeof val === 'number') {\n        if (typeof defaultVal === 'number' && Math.abs(val - defaultVal) < EPSILON) {\n            return '';\n        }\n        else {\n            return generateFloatProp(name, val, true, tabSize);\n        }\n    }\n    else {\n        return generateBlockStart(name, val.Keys.length, tabSize) +\n            generateBooleanProp(generateLineType(val.LineType), tabSize + 1) +\n            (val.GlobalSeqId !== null ? generateIntProp('GlobalSeqId', val.GlobalSeqId, null, tabSize + 1) : '') +\n            val.Keys.map(function (key) { return generateAnimKeyFrame(key, tabSize + 1, reverse); }).join('') +\n            generateBlockEnd(tabSize);\n    }\n}\nfunction generateVersion(model) {\n    return generateBlockStart('Version') +\n        generateIntProp('FormatVersion', model.Version) +\n        generateBlockEnd();\n}\nfunction generateModel(model) {\n    return generateBlockStart('Model', model.Info.Name) +\n        generateIntPropIfNotEmpty('NumGeosets', model.Geosets.length) +\n        generateIntPropIfNotEmpty('NumGeosetAnims', model.GeosetAnims.length) +\n        generateIntPropIfNotEmpty('NumHelpers', model.Helpers.length) +\n        generateIntPropIfNotEmpty('NumBones', model.Bones.length) +\n        (model.Lights.length ? generateIntPropIfNotEmpty('NumLights', model.Lights.length) : '') +\n        generateIntPropIfNotEmpty('NumAttachments', model.Attachments.length) +\n        generateIntPropIfNotEmpty('NumEvents', model.EventObjects.length) +\n        generateIntPropIfNotEmpty('NumParticleEmitters', model.ParticleEmitters.length) +\n        (model.ParticleEmitters2.length ?\n            generateIntPropIfNotEmpty('NumParticleEmitters2', model.ParticleEmitters2.length) :\n            '') +\n        (model.RibbonEmitters.length ?\n            generateIntPropIfNotEmpty('NumRibbonEmitters', model.RibbonEmitters.length) :\n            '') +\n        generateIntProp('BlendTime', model.Info.BlendTime) +\n        generateFloatArrayProp('MinimumExtent', model.Info.MinimumExtent) +\n        generateFloatArrayProp('MaximumExtent', model.Info.MaximumExtent) +\n        generateFloatPropIfNotEmpty('BoundsRadius', model.Info.BoundsRadius) +\n        generateBlockEnd();\n}\nfunction generateSequences(model) {\n    return generateBlockStart('Sequences', model.Sequences.length) +\n        model.Sequences.map(generateSequenceChunk).join('') +\n        generateBlockEnd();\n}\nfunction generateSequenceChunk(sequence) {\n    return generateBlockStart('Anim', sequence.Name, 1) +\n        generateUIntArrayProp('Interval', sequence.Interval, null, 2) +\n        generateFloatPropIfNotEmpty('Rarity', sequence.Rarity, 0, null, 2) +\n        generateFloatPropIfNotEmpty('MoveSpeed', sequence.MoveSpeed, 0, null, 2) +\n        (sequence.NonLooping ? generateBooleanProp('NonLooping', 2) : '') +\n        generateFloatArrayProp('MinimumExtent', sequence.MinimumExtent, null, 2) +\n        generateFloatArrayProp('MaximumExtent', sequence.MaximumExtent, null, 2) +\n        generateFloatPropIfNotEmpty('BoundsRadius', sequence.BoundsRadius, 0, null, 2) +\n        generateBlockEnd(1);\n}\nfunction generateGlobalSequences(model) {\n    if (!model.GlobalSequences || !model.GlobalSequences.length) {\n        return '';\n    }\n    return generateBlockStart('GlobalSequences', model.GlobalSequences.length) +\n        model.GlobalSequences.map(function (duration) { return generateIntProp('Duration', duration); }).join('') +\n        generateBlockEnd();\n}\nfunction generateTextures(model) {\n    if (!model.Textures.length) {\n        return '';\n    }\n    return generateBlockStart('Textures', model.Textures.length) +\n        model.Textures.map(generateTextureChunk).join('') +\n        generateBlockEnd();\n}\nfunction generateTextureChunk(texture) {\n    return generateBlockStart('Bitmap', null, 1) +\n        generateWrappedStringProp('Image', texture.Image, null, 2) +\n        generateIntPropIfNotEmpty('ReplaceableId', texture.ReplaceableId, 0, null, 2) +\n        (texture.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.TextureFlags.WrapWidth ? generateBooleanProp('WrapWidth', 2) : '') +\n        (texture.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.TextureFlags.WrapHeight ? generateBooleanProp('WrapHeight', 2) : '') +\n        generateBlockEnd(1);\n}\nfunction generateMaterials(model) {\n    if (!model.Materials.length) {\n        return '';\n    }\n    return generateBlockStart('Materials', model.Materials.length) +\n        model.Materials.map(function (it) { return generateMaterialChunk(model, it); }).join('') +\n        generateBlockEnd();\n}\nfunction generateMaterialChunk(model, material) {\n    var shader = '';\n    if (model.Version >= 900 && model.Version < 1100 && material.Shader) {\n        shader = generateWrappedStringProp('Shader', material.Shader, false, 2);\n    }\n    return generateBlockStart('Material', null, 1) +\n        (material.RenderMode & _model__WEBPACK_IMPORTED_MODULE_0__.MaterialRenderMode.ConstantColor ? generateBooleanProp('ConstantColor', 2) : '') +\n        (material.RenderMode & _model__WEBPACK_IMPORTED_MODULE_0__.MaterialRenderMode.SortPrimsFarZ ? generateBooleanProp('SortPrimsFarZ', 2) : '') +\n        (material.RenderMode & _model__WEBPACK_IMPORTED_MODULE_0__.MaterialRenderMode.FullResolution ? generateBooleanProp('FullResolution', 2) : '') +\n        generateIntPropIfNotEmpty('PriorityPlane', material.PriorityPlane, 0, null, 2) +\n        generateIntPropIfNotEmpty('RenderMode', material.RenderMode, 0, null, 2) +\n        shader +\n        material.Layers.map(function (it) { return generateLayerChunk(model, it); }).join('') +\n        generateBlockEnd(1);\n}\nfunction generateFilterMode(filterMode) {\n    switch (filterMode) {\n        case _model__WEBPACK_IMPORTED_MODULE_0__.FilterMode.None:\n            return 'None';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.FilterMode.Transparent:\n            return 'Transparent';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.FilterMode.Blend:\n            return 'Blend';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.FilterMode.Additive:\n            return 'Additive';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.FilterMode.AddAlpha:\n            return 'AddAlpha';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.FilterMode.Modulate:\n            return 'Modulate';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.FilterMode.Modulate2x:\n            return 'Modulate2x';\n    }\n    return '';\n}\nfunction generateLayerChunk(model, layer) {\n    var middle = '';\n    if (model.Version >= 900) {\n        middle += (layer.EmissiveGain !== undefined ? generateAnimVectorProp('EmissiveGain', layer.EmissiveGain, 1, 3) : '');\n        if (model.Version >= 1000) {\n            middle += (layer.FresnelColor !== undefined ? generateColorProp('FresnelColor', layer.FresnelColor, true, 3) : '');\n            middle += (layer.FresnelOpacity !== undefined ? generateAnimVectorProp('FresnelOpacity', layer.FresnelOpacity, 0, 3) : '');\n            middle += (layer.FresnelTeamColor !== undefined ? generateAnimVectorProp('FresnelTeamColor', layer.FresnelTeamColor, 0, 3) : '');\n        }\n    }\n    if (model.Version >= 1100) {\n        middle += generateIntProp('ShaderTypeId', layer.ShaderTypeId || 0, null, 3);\n        _renderer_util__WEBPACK_IMPORTED_MODULE_1__.LAYER_TEXTURE_ID_MAP.slice(1).forEach(function (name) {\n            var val = layer[name];\n            if (val !== undefined) {\n                middle += generateAnimVectorProp(name, val, null, 3);\n            }\n        });\n    }\n    return generateBlockStart('Layer', null, 2) +\n        generateStringProp('FilterMode', generateFilterMode(layer.FilterMode), null, 3) +\n        (layer.Alpha !== undefined ? generateAnimVectorProp('Alpha', layer.Alpha, 1, 3) : '') +\n        (layer.TextureID !== undefined ? generateAnimVectorProp('TextureID', layer.TextureID, null, 3) : '') +\n        (layer.Shading & _model__WEBPACK_IMPORTED_MODULE_0__.LayerShading.TwoSided ? generateBooleanProp('TwoSided', 3) : '') +\n        (layer.Shading & _model__WEBPACK_IMPORTED_MODULE_0__.LayerShading.Unshaded ? generateBooleanProp('Unshaded', 3) : '') +\n        (layer.Shading & _model__WEBPACK_IMPORTED_MODULE_0__.LayerShading.Unfogged ? generateBooleanProp('Unfogged', 3) : '') +\n        (layer.Shading & _model__WEBPACK_IMPORTED_MODULE_0__.LayerShading.SphereEnvMap ? generateBooleanProp('SphereEnvMap', 3) : '') +\n        (layer.Shading & _model__WEBPACK_IMPORTED_MODULE_0__.LayerShading.NoDepthTest ? generateBooleanProp('NoDepthTest', 3) : '') +\n        (layer.Shading & _model__WEBPACK_IMPORTED_MODULE_0__.LayerShading.NoDepthSet ? generateBooleanProp('NoDepthSet', 3) : '') +\n        generateIntPropIfNotEmpty('CoordId', layer.CoordId, 0, null, 3) +\n        generateIntPropIfNotEmpty('TVertexAnimId', layer.TVertexAnimId, null, null, 3) +\n        middle +\n        generateBlockEnd(2);\n}\nfunction generateTextureAnims(model) {\n    if (!model.TextureAnims.length) {\n        return '';\n    }\n    return generateBlockStart('TextureAnims', model.TextureAnims.length) +\n        model.TextureAnims.map(generateTextureAnimChunk).join('') +\n        generateBlockEnd();\n}\nfunction generateTextureAnimChunk(textureAnim) {\n    return generateBlockStart('TVertexAnim', null, 1) +\n        (textureAnim.Translation ? generateAnimVectorProp('Translation', textureAnim.Translation, null, 2) : '') +\n        (textureAnim.Rotation ? generateAnimVectorProp('Rotation', textureAnim.Rotation, null, 2) : '') +\n        (textureAnim.Scaling ? generateAnimVectorProp('Scaling', textureAnim.Scaling, null, 2) : '') +\n        generateBlockEnd(1);\n}\nfunction generateGeosets(model) {\n    if (!model.Geosets.length) {\n        return '';\n    }\n    return model.Geosets.map(function (it) { return generateGeosetChunk(model, it); }).join('');\n}\nfunction generateGeosetChunk(model, geoset) {\n    var middle = '';\n    if (model.Version >= 900) {\n        middle += (geoset.LevelOfDetail !== undefined ? generateIntProp('LevelOfDetail', geoset.LevelOfDetail) : '') +\n            (geoset.Name ? generateWrappedStringProp('Name', geoset.Name) : '') +\n            (geoset.Tangents ? generateGeosetArray('Tangents', geoset.Tangents, 4) : '') +\n            (geoset.SkinWeights ? generateGeosetArray('SkinWeights', geoset.SkinWeights, 8) : '');\n    }\n    return generateBlockStart('Geoset') +\n        generateGeosetArray('Vertices', geoset.Vertices, 3) +\n        generateGeosetArray('Normals', geoset.Normals, 3) +\n        generateGeosetArray('TVertices', geoset.TVertices[0], 2) +\n        generateGeosetVertexGroup(geoset.VertexGroup) +\n        generateGeosetFaces(geoset.Faces) +\n        generateGeosetGroups(geoset.Groups) +\n        generateFloatArrayProp('MinimumExtent', geoset.MinimumExtent) +\n        generateFloatArrayProp('MaximumExtent', geoset.MaximumExtent) +\n        generateFloatPropIfNotEmpty('BoundsRadius', geoset.BoundsRadius) +\n        generateGeosetAnimInfos(geoset.Anims) +\n        generateIntProp('MaterialID', geoset.MaterialID) +\n        generateIntProp('SelectionGroup', geoset.SelectionGroup) +\n        (geoset.Unselectable ? generateBooleanProp('Unselectable') : '') +\n        middle +\n        generateBlockEnd();\n}\nfunction generateGeosetArray(name, arr, elemLength) {\n    var middle = '';\n    var elemCount = arr.length / elemLength;\n    for (var i = 0; i < elemCount; ++i) {\n        middle += generateTab(2) + generateArray(arr.slice(i * elemLength, (i + 1) * elemLength)) + ',\\n';\n    }\n    return generateBlockStart(name, elemCount, 1) +\n        middle +\n        generateBlockEnd(1);\n}\nfunction generateGeosetVertexGroup(arr) {\n    if (!arr.length) {\n        return '';\n    }\n    var middle = '';\n    for (var i = 0; i < arr.length; ++i) {\n        middle += generateTab(2) + arr[i] + ',\\n';\n    }\n    return generateBlockStart('VertexGroup', null, 1) +\n        middle +\n        generateBlockEnd(1);\n}\nfunction generateGeosetFaces(arr) {\n    return generateBlockStart(\"Faces 1 \".concat(arr.length), null, 1) +\n        generateBlockStart('Triangles', null, 2) +\n        generateTab(3) + generateUIntArray(arr) + ',\\n' +\n        generateBlockEnd(2) +\n        generateBlockEnd(1);\n}\nfunction generateGeosetGroups(groups) {\n    var totalMatrices = 0;\n    var middle = '';\n    for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {\n        var group = groups_1[_i];\n        totalMatrices += group.length;\n        middle += generateTab(2) + 'Matrices ' + generateUIntArray(group) + ',\\n';\n    }\n    return generateBlockStart(\"Groups \".concat(groups.length, \" \").concat(totalMatrices), null, 1) +\n        middle +\n        generateBlockEnd(1);\n}\nfunction generateGeosetAnimInfos(anims) {\n    if (!anims) {\n        return '';\n    }\n    return anims.map(generateGeosetAnimInfoChunk).join('');\n}\nfunction generateGeosetAnimInfoChunk(anim) {\n    return generateBlockStart('Anim', null, 1) +\n        generateFloatArrayProp('MinimumExtent', anim.MinimumExtent, null, 2) +\n        generateFloatArrayProp('MaximumExtent', anim.MaximumExtent, null, 2) +\n        generateFloatPropIfNotEmpty('BoundsRadius', anim.BoundsRadius, 0, null, 2) +\n        generateBlockEnd(1);\n}\nfunction generateGeosetAnims(model) {\n    if (!model.GeosetAnims.length) {\n        return '';\n    }\n    return model.GeosetAnims.map(generateGeosetAnimChunk).join('');\n}\nfunction generateColorProp(name, color, isStatic, tabSize) {\n    if (tabSize === void 0) { tabSize = 1; }\n    if (color) {\n        if (color instanceof Float32Array) {\n            if (!isStatic || isNotEmptyVec3(color, 1)) {\n                var middle = '';\n                for (var i = 2; i >= 0; --i) {\n                    if (i < 2) {\n                        middle += ', ';\n                    }\n                    middle += generateNumber(color[i]);\n                }\n                return \"\".concat(generateTab(tabSize)).concat(isStatic ? 'static ' : '').concat(name, \" { \").concat(middle, \" },\\n\");\n            }\n        }\n        else {\n            return generateAnimVectorProp(name, color, null, tabSize, true);\n        }\n    }\n    return '';\n}\nfunction generateGeosetAnimChunk(geosetAnim) {\n    return generateBlockStart('GeosetAnim') +\n        generateIntProp('GeosetId', geosetAnim.GeosetId) +\n        generateAnimVectorProp('Alpha', geosetAnim.Alpha, 1) +\n        generateColorProp('Color', geosetAnim.Color, true) +\n        (geosetAnim.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.GeosetAnimFlags.DropShadow ? generateBooleanProp('DropShadow') : '') +\n        generateBlockEnd();\n}\nfunction generateNodeProps(node) {\n    return generateIntProp('ObjectId', node.ObjectId) +\n        generateIntPropIfNotEmpty('Parent', node.Parent, null) +\n        generateNodeDontInherit(node.Flags) +\n        (node.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.Billboarded ? generateBooleanProp('Billboarded') : '') +\n        (node.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.BillboardedLockX ? generateBooleanProp('BillboardedLockX') : '') +\n        (node.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.BillboardedLockY ? generateBooleanProp('BillboardedLockY') : '') +\n        (node.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.BillboardedLockZ ? generateBooleanProp('BillboardedLockZ') : '') +\n        (node.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.CameraAnchored ? generateBooleanProp('CameraAnchored') : '') +\n        (node.Translation !== undefined ? generateAnimVectorProp('Translation', node.Translation) : '') +\n        (node.Rotation !== undefined ? generateAnimVectorProp('Rotation', node.Rotation) : '') +\n        (node.Scaling !== undefined ? generateAnimVectorProp('Scaling', node.Scaling) : '');\n}\nfunction generateNodeDontInherit(flags) {\n    var flagsStrs = [];\n    if (flags & _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritTranslation) {\n        flagsStrs.push('Translation');\n    }\n    if (flags & _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritRotation) {\n        flagsStrs.push('Rotation');\n    }\n    if (flags & _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritScaling) {\n        flagsStrs.push('Scaling');\n    }\n    if (!flagsStrs.length) {\n        return '';\n    }\n    return generateTab(1) + 'DontInherit { ' + flagsStrs.join(', ') + ' },\\n';\n}\nfunction generateBones(model) {\n    if (!model.Bones.length) {\n        return '';\n    }\n    return model.Bones.map(generateBoneChunk).join('');\n}\nfunction generateBoneChunk(bone) {\n    return generateBlockStart('Bone', bone.Name) +\n        generateNodeProps(bone) +\n        (bone.GeosetId !== null ?\n            generateIntProp('GeosetId', bone.GeosetId) :\n            generateStringProp('GeosetId', 'Multiple')) +\n        (bone.GeosetAnimId !== null ?\n            generateIntProp('GeosetAnimId', bone.GeosetAnimId) :\n            generateStringProp('GeosetAnimId', 'None')) +\n        generateBlockEnd();\n}\nfunction generateLights(model) {\n    if (!model.Lights.length) {\n        return '';\n    }\n    return model.Lights.map(generateLightChunk).join('');\n}\nfunction generateLightChunk(light) {\n    return generateBlockStart('Light', light.Name) +\n        generateNodeProps(light) +\n        generateBooleanProp(generateLightType(light.LightType)) +\n        generateAnimVectorProp('AttenuationStart', light.AttenuationStart) +\n        generateAnimVectorProp('AttenuationEnd', light.AttenuationEnd) +\n        generateColorProp('Color', light.Color, true) +\n        generateAnimVectorProp('Intensity', light.Intensity, null) +\n        generateColorProp('AmbColor', light.AmbColor, true) +\n        generateAnimVectorProp('AmbIntensity', light.AmbIntensity, null) +\n        generateAnimVectorProp('Visibility', light.Visibility, 1) +\n        generateBlockEnd();\n}\nfunction generateLightType(lightType) {\n    switch (lightType) {\n        case _model__WEBPACK_IMPORTED_MODULE_0__.LightType.Omnidirectional:\n            return 'Omnidirectional';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.LightType.Directional:\n            return 'Directional';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.LightType.Ambient:\n            return 'Ambient';\n    }\n    return '';\n}\nfunction generateHelpers(model) {\n    return model.Helpers.map(generateHelperChunk).join('');\n}\nfunction generateHelperChunk(helper) {\n    return generateBlockStart('Helper', helper.Name) +\n        generateNodeProps(helper) +\n        generateBlockEnd();\n}\nfunction generateAttachments(model) {\n    return model.Attachments.map(generateAttachmentChunk).join('');\n}\nfunction generateAttachmentChunk(attachment) {\n    return generateBlockStart('Attachment', attachment.Name) +\n        generateNodeProps(attachment) +\n        generateIntProp('AttachmentID', attachment.AttachmentID) +\n        (attachment.Path ? generateWrappedStringProp('Path', attachment.Path) : '') +\n        generateAnimVectorProp('Visibility', attachment.Visibility, 1) +\n        generateBlockEnd();\n}\nfunction generatePivotPoints(model) {\n    return generateBlockStart('PivotPoints', model.PivotPoints.length) +\n        model.PivotPoints.map(function (point) { return \"\".concat(generateTab()).concat(generateArray(point), \",\\n\"); }).join('') +\n        generateBlockEnd();\n}\nfunction generateParticleEmitters(model) {\n    return model.ParticleEmitters.map(generateParticleEmitterChunk).join('');\n}\nfunction generateParticleEmitterChunk(emitter) {\n    return generateBlockStart('ParticleEmitter', emitter.Name) +\n        generateNodeProps(emitter) +\n        (emitter.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterFlags.EmitterUsesMDL ? generateBooleanProp('EmitterUsesMDL') : '') +\n        (emitter.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterFlags.EmitterUsesTGA ? generateBooleanProp('EmitterUsesTGA') : '') +\n        generateAnimVectorProp('EmissionRate', emitter.EmissionRate) +\n        generateAnimVectorProp('Gravity', emitter.Gravity) +\n        generateAnimVectorProp('Longitude', emitter.Longitude) +\n        generateAnimVectorProp('Latitude', emitter.Latitude) +\n        generateAnimVectorProp('Visibility', emitter.Visibility) +\n        generateBlockStart('Particle', null, 1) +\n        generateAnimVectorProp('LifeSpan', emitter.LifeSpan, null, 2) +\n        generateAnimVectorProp('InitVelocity', emitter.InitVelocity, null, 2) +\n        generateWrappedStringProp('Path', emitter.Path, false, 2) +\n        generateBlockEnd(1) +\n        generateBlockEnd();\n}\nfunction generateParticleEmitters2(model) {\n    return model.ParticleEmitters2.map(generateParticleEmitter2Chunk).join('');\n}\nfunction generateParticleEmitters2FilterMode(filterMode) {\n    switch (filterMode) {\n        case _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FilterMode.Blend:\n            return 'Blend';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FilterMode.Additive:\n            return 'Additive';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FilterMode.Modulate:\n            return 'Modulate';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FilterMode.Modulate2x:\n            return 'Modulate2x';\n        case _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FilterMode.AlphaKey:\n            return 'AlphaKey';\n    }\n    return '';\n}\nfunction generateSegmentColor(colors) {\n    return generateBlockStart('SegmentColor', null, 1) +\n        colors.map(function (color) { return generateColorProp('Color', color, false, 2); }).join('') +\n        generateTab() + '},\\n';\n}\nfunction generateParticleEmitter2FrameFlags(frameFlags) {\n    if (frameFlags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Head && frameFlags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Tail) {\n        return 'Both';\n    }\n    else if (frameFlags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Head) {\n        return 'Head';\n    }\n    else if (frameFlags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Tail) {\n        return 'Tail';\n    }\n    return '';\n}\nfunction generateParticleEmitter2Chunk(particleEmitter2) {\n    return generateBlockStart('ParticleEmitter2', particleEmitter2.Name) +\n        generateNodeProps(particleEmitter2) +\n        generateBooleanProp(generateParticleEmitters2FilterMode(particleEmitter2.FilterMode)) +\n        generateAnimVectorProp('Speed', particleEmitter2.Speed, null) +\n        generateAnimVectorProp('Variation', particleEmitter2.Variation, null) +\n        generateAnimVectorProp('Latitude', particleEmitter2.Latitude, null) +\n        generateAnimVectorProp('Gravity', particleEmitter2.Gravity, null) +\n        generateAnimVectorProp('EmissionRate', particleEmitter2.EmissionRate, null) +\n        generateAnimVectorProp('Width', particleEmitter2.Width, null) +\n        generateAnimVectorProp('Length', particleEmitter2.Length, null) +\n        generateAnimVectorProp('Visibility', particleEmitter2.Visibility, 1) +\n        generateSegmentColor(particleEmitter2.SegmentColor) +\n        generateUIntArrayProp('Alpha', particleEmitter2.Alpha) +\n        generateFloatArrayProp('ParticleScaling', particleEmitter2.ParticleScaling) +\n        generateFloatArrayProp('LifeSpanUVAnim', particleEmitter2.LifeSpanUVAnim) +\n        generateFloatArrayProp('DecayUVAnim', particleEmitter2.DecayUVAnim) +\n        generateFloatArrayProp('TailUVAnim', particleEmitter2.TailUVAnim) +\n        generateFloatArrayProp('TailDecayUVAnim', particleEmitter2.TailDecayUVAnim) +\n        generateIntPropIfNotEmpty('Rows', particleEmitter2.Rows, 0) +\n        generateIntPropIfNotEmpty('Columns', particleEmitter2.Columns, 0) +\n        generateIntProp('TextureID', particleEmitter2.TextureID) +\n        generateIntPropIfNotEmpty('Time', particleEmitter2.Time, 0) +\n        generateIntPropIfNotEmpty('LifeSpan', particleEmitter2.LifeSpan, 0) +\n        generateIntPropIfNotEmpty('TailLength', particleEmitter2.TailLength, 0) +\n        generateIntPropIfNotEmpty('PriorityPlane', particleEmitter2.PriorityPlane, 0) +\n        generateIntPropIfNotEmpty('ReplaceableId', particleEmitter2.ReplaceableId, null) +\n        (particleEmitter2.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2Flags.SortPrimsFarZ ? generateBooleanProp('SortPrimsFarZ') : '') +\n        (particleEmitter2.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2Flags.LineEmitter ? generateBooleanProp('LineEmitter') : '') +\n        (particleEmitter2.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2Flags.ModelSpace ? generateBooleanProp('ModelSpace') : '') +\n        (particleEmitter2.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2Flags.Unshaded ? generateBooleanProp('Unshaded') : '') +\n        (particleEmitter2.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2Flags.Unfogged ? generateBooleanProp('Unfogged') : '') +\n        (particleEmitter2.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2Flags.XYQuad ? generateBooleanProp('XYQuad') : '') +\n        (particleEmitter2.Squirt ? generateBooleanProp('Squirt') : '') +\n        generateBooleanProp(generateParticleEmitter2FrameFlags(particleEmitter2.FrameFlags)) +\n        generateBlockEnd();\n}\nfunction generateRibbonEmitters(model) {\n    return model.RibbonEmitters.map(generateRibbonEmitterChunk).join('');\n}\nfunction generateRibbonEmitterChunk(ribbonEmitter) {\n    return generateBlockStart('RibbonEmitter', ribbonEmitter.Name) +\n        generateNodeProps(ribbonEmitter) +\n        generateAnimVectorProp('HeightAbove', ribbonEmitter.HeightAbove, null) +\n        generateAnimVectorProp('HeightBelow', ribbonEmitter.HeightBelow, null) +\n        generateAnimVectorProp('Alpha', ribbonEmitter.Alpha, null) +\n        generateColorProp('Color', ribbonEmitter.Color, true) +\n        generateAnimVectorProp('TextureSlot', ribbonEmitter.TextureSlot, null) +\n        generateAnimVectorProp('Visibility', ribbonEmitter.Visibility, 1) +\n        generateIntProp('EmissionRate', ribbonEmitter.EmissionRate) +\n        generateIntProp('LifeSpan', ribbonEmitter.LifeSpan) +\n        generateIntPropIfNotEmpty('Gravity', ribbonEmitter.Gravity, 0) +\n        generateIntProp('Rows', ribbonEmitter.Rows) +\n        generateIntProp('Columns', ribbonEmitter.Columns) +\n        generateIntProp('MaterialID', ribbonEmitter.MaterialID) +\n        generateBlockEnd();\n}\nfunction generateEventObjects(model) {\n    return model.EventObjects.map(generateEventObjectChunk).join('');\n}\nfunction generateEventTrack(eventTrack) {\n    var middle = '';\n    for (var i = 0; i < eventTrack.length; ++i) {\n        middle += generateTab(2) + eventTrack[i] + ',\\n';\n    }\n    return generateBlockStart('EventTrack', eventTrack.length, 1) +\n        middle +\n        generateBlockEnd(1);\n}\nfunction generateEventObjectChunk(eventObject) {\n    return generateBlockStart('EventObject', eventObject.Name) +\n        generateNodeProps(eventObject) +\n        generateEventTrack(eventObject.EventTrack) +\n        generateBlockEnd();\n}\nfunction generateCameras(model) {\n    return model.Cameras.map(generateCameraChunk).join('');\n}\nfunction generateCameraChunk(camera) {\n    return generateBlockStart('Camera', camera.Name) +\n        generateFloatProp('FieldOfView', camera.FieldOfView) +\n        generateFloatProp('FarClip', camera.FarClip) +\n        generateFloatProp('NearClip', camera.NearClip) +\n        generateFloatArrayProp('Position', camera.Position) +\n        generateAnimVectorProp('Translation', camera.Translation) +\n        generateAnimVectorProp('Rotation', camera.Rotation) +\n        generateBlockStart('Target', null, 1) +\n        generateFloatArrayProp('Position', camera.TargetPosition, null, 2) +\n        generateAnimVectorProp('Translation', camera.TargetTranslation, null, 2) +\n        generateBlockEnd(1) +\n        generateBlockEnd();\n}\nfunction generateCollisionShapes(model) {\n    return model.CollisionShapes.map(generateCollisionShapeChunk).join('');\n}\nfunction generateCollisionShapeChunk(collisionShape) {\n    var middle = '';\n    if (collisionShape.Shape === _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Box) {\n        middle = generateBooleanProp('Box');\n        middle += generateBlockStart('Vertices', 2, 1) +\n            generateTab(2) + generateArray(collisionShape.Vertices.slice(0, 3)) + ',\\n' +\n            generateTab(2) + generateArray(collisionShape.Vertices.slice(3, 6)) + ',\\n' +\n            generateBlockEnd(1);\n    }\n    else {\n        middle = generateBooleanProp('Sphere');\n        middle += generateBlockStart('Vertices', 1, 1) +\n            generateTab(2) + generateArray(collisionShape.Vertices) + ',\\n' +\n            generateBlockEnd(1) +\n            generateFloatProp('BoundsRadius', collisionShape.BoundsRadius);\n    }\n    return generateBlockStart('CollisionShape', collisionShape.Name) +\n        generateNodeProps(collisionShape) +\n        middle +\n        generateBlockEnd();\n}\nfunction generateFaceFX(model) {\n    if (model.Version < 900 || !model.FaceFX) {\n        return '';\n    }\n    return model.FaceFX.map(generateFaceFXChunk).join('');\n}\nfunction generateFaceFXChunk(faceFX) {\n    return generateBlockStart('FaceFX', faceFX.Name) +\n        generateWrappedStringProp('Path', faceFX.Path) +\n        generateBlockEnd();\n}\nfunction generateBindPose(model) {\n    if (model.Version < 900 || !model.BindPoses) {\n        return '';\n    }\n    return model.BindPoses.map(generateBindPoseChunk).join('');\n}\nfunction generateBindPoseChunk(bindPose) {\n    var middle = generateBlockStart('Matrices', bindPose.Matrices.length, 1) +\n        bindPose.Matrices.map(function (item) {\n            return generateTab(2) + generateArray(item) + ',';\n        }).join('\\n') + '\\n' +\n        generateBlockEnd(1);\n    return generateBlockStart('BindPose') +\n        middle +\n        generateBlockEnd();\n}\nfunction generateParticleEmitterPopcorn(model) {\n    if (model.Version < 900 || !model.ParticleEmitterPopcorns) {\n        return '';\n    }\n    return model.ParticleEmitterPopcorns.map(generateParticleEmitterPopcornChunk).join('');\n}\nfunction generateParticleEmitterPopcornChunk(emitter) {\n    return generateBlockStart('ParticleEmitterPopcorn', emitter.Name) +\n        generateNodeProps(emitter) +\n        (emitter.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterPopcornFlags.Unshaded ? generateBooleanProp('Unshaded') : '') +\n        (emitter.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterPopcornFlags.SortPrimsFarZ ? generateBooleanProp('SortPrimsFarZ') : '') +\n        (emitter.Flags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterPopcornFlags.Unfogged ? generateBooleanProp('Unfogged') : '') +\n        generateAnimVectorProp('LifeSpan', emitter.LifeSpan, null) +\n        generateAnimVectorProp('EmissionRate', emitter.EmissionRate, 0) +\n        generateAnimVectorProp('Speed', emitter.Speed, 0) +\n        generateColorProp('Color', emitter.Color, true) +\n        generateAnimVectorProp('Alpha', emitter.Alpha, 1) +\n        generateIntPropIfNotEmpty('ReplaceableId', emitter.ReplaceableId, 0, null) +\n        generateWrappedStringProp('Path', emitter.Path, false) +\n        generateWrappedStringProp('AnimVisibilityGuide', emitter.AnimVisibilityGuide, false) +\n        generateAnimVectorProp('Visibility', emitter.Visibility) +\n        generateBlockEnd();\n}\nvar generators = [\n    generateVersion,\n    generateModel,\n    generateSequences,\n    generateGlobalSequences,\n    generateTextures,\n    generateMaterials,\n    generateTextureAnims,\n    generateGeosets,\n    generateGeosetAnims,\n    generateBones,\n    generateLights,\n    generateHelpers,\n    generateAttachments,\n    generatePivotPoints,\n    generateParticleEmitters,\n    generateParticleEmitters2,\n    generateRibbonEmitters,\n    generateEventObjects,\n    generateCameras,\n    generateCollisionShapes,\n    generateFaceFX,\n    generateBindPose,\n    generateParticleEmitterPopcorn\n];\nfunction generate(model) {\n    var res = '';\n    for (var _i = 0, generators_1 = generators; _i < generators_1.length; _i++) {\n        var generator = generators_1[_i];\n        res += generator(model);\n    }\n    return res;\n}\n\n\n//# sourceURL=webpack://war3-model/./mdl/generate.ts?");

/***/ }),

/***/ "./mdl/parse.ts":
/*!**********************!*\
  !*** ./mdl/parse.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model */ \"./model.ts\");\n/* harmony import */ var _renderer_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/util */ \"./renderer/util.ts\");\nvar _a;\n\n\nvar State = /** @class */ (function () {\n    function State(str) {\n        this.str = str;\n        this.pos = 0;\n    }\n    State.prototype.char = function () {\n        if (this.pos >= this.str.length) {\n            throwError(this, 'incorrect model data');\n        }\n        return this.str[this.pos];\n    };\n    return State;\n}());\nfunction throwError(state, str) {\n    if (str === void 0) { str = ''; }\n    throw new Error(\"SyntaxError, near \".concat(state.pos) + (str ? ', ' + str : ''));\n}\nfunction parseComment(state) {\n    if (state.char() === '/' && state.str[state.pos + 1] === '/') {\n        state.pos += 2;\n        while (state.pos < state.str.length && state.str[++state.pos] !== '\\n')\n            ;\n        ++state.pos;\n        return true;\n    }\n    return false;\n}\nvar spaceRE = /\\s/i;\nfunction parseSpace(state) {\n    while (state.pos < state.str.length && spaceRE.test(state.char())) {\n        ++state.pos;\n    }\n}\nvar keywordFirstCharRE = /[a-z]/i;\nvar keywordOtherCharRE = /[a-z0-9]/i;\nfunction parseKeyword(state) {\n    if (!keywordFirstCharRE.test(state.char())) {\n        return null;\n    }\n    var keyword = state.char();\n    ++state.pos;\n    while (keywordOtherCharRE.test(state.char())) {\n        keyword += state.str[state.pos++];\n    }\n    parseSpace(state);\n    return keyword;\n}\nfunction parseSymbol(state, symbol) {\n    if (state.char() === symbol) {\n        ++state.pos;\n        parseSpace(state);\n    }\n}\nfunction strictParseSymbol(state, symbol) {\n    if (state.char() !== symbol) {\n        throwError(state, \"extected \".concat(symbol));\n    }\n    ++state.pos;\n    parseSpace(state);\n}\nfunction parseString(state) {\n    if (state.char() === '\"') {\n        var start = ++state.pos; // \"\n        while (state.char() !== '\"') {\n            ++state.pos;\n        }\n        ++state.pos; // \"\n        var res = state.str.substring(start, state.pos - 1);\n        parseSpace(state);\n        return res;\n    }\n    return null;\n}\nvar numberFirstCharRE = /[-0-9]/;\nvar numberOtherCharRE = /[-+.0-9e]/i;\nfunction parseNumber(state) {\n    if (numberFirstCharRE.test(state.char())) {\n        var start = state.pos;\n        ++state.pos;\n        while (numberOtherCharRE.test(state.char())) {\n            ++state.pos;\n        }\n        var res = parseFloat(state.str.substring(start, state.pos));\n        parseSpace(state);\n        return res;\n    }\n    return null;\n}\nfunction parseArray(state, arr, pos) {\n    if (state.char() !== '{') {\n        return null;\n    }\n    if (!arr) {\n        arr = [];\n        pos = 0;\n    }\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var num = parseNumber(state);\n        if (num === null) {\n            throwError(state, 'expected number');\n        }\n        arr[pos++] = num;\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    return arr;\n}\nfunction parseArrayCounted(state, arr, pos) {\n    if (state.char() !== '{') {\n        return 0;\n    }\n    var start = pos;\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var num = parseNumber(state);\n        if (num === null) {\n            throwError(state, 'expected number');\n        }\n        arr[pos++] = num;\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    return pos - start;\n}\nfunction parseArrayOrSingleItem(state, arr) {\n    if (state.char() !== '{') {\n        arr[0] = parseNumber(state);\n        return arr;\n    }\n    var pos = 0;\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var num = parseNumber(state);\n        if (num === null) {\n            throwError(state, 'expected number');\n        }\n        arr[pos++] = num;\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    return arr;\n}\nfunction parseObject(state) {\n    var prefix = null;\n    var obj = {};\n    if (state.char() !== '{') {\n        prefix = parseString(state);\n        if (prefix === null) {\n            prefix = parseNumber(state);\n        }\n        if (prefix === null) {\n            throwError(state, 'expected string or number');\n        }\n    }\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'Interval') {\n            var array = new Uint32Array(2);\n            obj[keyword] = parseArray(state, array, 0);\n        }\n        else if (keyword === 'MinimumExtent' || keyword === 'MaximumExtent') {\n            var array = new Float32Array(3);\n            obj[keyword] = parseArray(state, array, 0);\n        }\n        else {\n            obj[keyword] = parseArray(state) || parseString(state);\n            if (obj[keyword] === null) {\n                obj[keyword] = parseNumber(state);\n            }\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    return [prefix, obj];\n}\nfunction parseVersion(state, model) {\n    var _a = parseObject(state), _unused = _a[0], obj = _a[1];\n    if (obj.FormatVersion) {\n        model.Version = obj.FormatVersion;\n    }\n}\nfunction parseModelInfo(state, model) {\n    var _a = parseObject(state), name = _a[0], obj = _a[1];\n    model.Info = obj;\n    model.Info.Name = name;\n}\nfunction parseSequences(state, model) {\n    parseNumber(state); // count, not used\n    strictParseSymbol(state, '{');\n    var res = [];\n    while (state.char() !== '}') {\n        parseKeyword(state); // Anim\n        var _a = parseObject(state), name = _a[0], obj = _a[1];\n        obj.Name = name;\n        obj.NonLooping = 'NonLooping' in obj;\n        obj.MoveSpeed = obj.MoveSpeed || 0;\n        obj.Rarity = obj.Rarity || 0;\n        res.push(obj);\n    }\n    strictParseSymbol(state, '}');\n    model.Sequences = res;\n}\nfunction parseTextures(state, model) {\n    var res = [];\n    parseNumber(state); // count, not used\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        parseKeyword(state); // Bitmap\n        var _a = parseObject(state), _unused = _a[0], obj = _a[1];\n        obj.Flags = 0;\n        if ('WrapWidth' in obj) {\n            obj.Flags += _model__WEBPACK_IMPORTED_MODULE_0__.TextureFlags.WrapWidth;\n            delete obj.WrapWidth;\n        }\n        if ('WrapHeight' in obj) {\n            obj.Flags += _model__WEBPACK_IMPORTED_MODULE_0__.TextureFlags.WrapHeight;\n            delete obj.WrapHeight;\n        }\n        res.push(obj);\n    }\n    strictParseSymbol(state, '}');\n    model.Textures = res;\n}\nvar AnimVectorType;\n(function (AnimVectorType) {\n    AnimVectorType[AnimVectorType[\"INT1\"] = 0] = \"INT1\";\n    AnimVectorType[AnimVectorType[\"FLOAT1\"] = 1] = \"FLOAT1\";\n    AnimVectorType[AnimVectorType[\"FLOAT3\"] = 2] = \"FLOAT3\";\n    AnimVectorType[AnimVectorType[\"FLOAT4\"] = 3] = \"FLOAT4\";\n})(AnimVectorType || (AnimVectorType = {}));\nvar animVectorSize = (_a = {},\n    _a[AnimVectorType.INT1] = 1,\n    _a[AnimVectorType.FLOAT1] = 1,\n    _a[AnimVectorType.FLOAT3] = 3,\n    _a[AnimVectorType.FLOAT4] = 4,\n    _a);\nfunction parseAnimKeyframe(state, frame, type, lineType) {\n    var res = {\n        Frame: frame,\n        Vector: null\n    };\n    var Vector = type === AnimVectorType.INT1 ? Int32Array : Float32Array;\n    var itemCount = animVectorSize[type];\n    res.Vector = parseArrayOrSingleItem(state, new Vector(itemCount));\n    strictParseSymbol(state, ',');\n    if (lineType === _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Hermite || lineType === _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Bezier) {\n        parseKeyword(state); // InTan\n        res.InTan = parseArrayOrSingleItem(state, new Vector(itemCount));\n        strictParseSymbol(state, ',');\n        parseKeyword(state); // OutTan\n        res.OutTan = parseArrayOrSingleItem(state, new Vector(itemCount));\n        strictParseSymbol(state, ',');\n    }\n    return res;\n}\nfunction parseAnimVector(state, type) {\n    var animVector = {\n        LineType: _model__WEBPACK_IMPORTED_MODULE_0__.LineType.DontInterp,\n        GlobalSeqId: null,\n        Keys: []\n    };\n    parseNumber(state); // count, not used\n    strictParseSymbol(state, '{');\n    var lineType = parseKeyword(state);\n    if (lineType === 'DontInterp' || lineType === 'Linear' || lineType === 'Hermite' || lineType === 'Bezier') {\n        animVector.LineType = _model__WEBPACK_IMPORTED_MODULE_0__.LineType[lineType];\n    }\n    strictParseSymbol(state, ',');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        if (keyword === 'GlobalSeqId') {\n            animVector[keyword] = parseNumber(state);\n            strictParseSymbol(state, ',');\n        }\n        else {\n            var frame = parseNumber(state);\n            if (frame === null) {\n                throwError(state, 'expected frame number or GlobalSeqId');\n            }\n            strictParseSymbol(state, ':');\n            animVector.Keys.push(parseAnimKeyframe(state, frame, type, animVector.LineType));\n        }\n    }\n    strictParseSymbol(state, '}');\n    return animVector;\n}\nfunction parseLayer(state, model) {\n    var res = {\n        Alpha: null,\n        TVertexAnimId: null,\n        Shading: 0,\n        CoordId: 0\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        var isStatic = false;\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'static') {\n            isStatic = true;\n            keyword = parseKeyword(state);\n        }\n        if (!isStatic && (keyword === 'TextureID' || model.Version >= 1100 && keyword in _renderer_util__WEBPACK_IMPORTED_MODULE_1__.LAYER_TEXTURE_NAME_MAP)) {\n            res[keyword] = parseAnimVector(state, AnimVectorType.INT1);\n        }\n        else if (!isStatic && (keyword === 'Alpha')) {\n            res[keyword] = parseAnimVector(state, AnimVectorType.FLOAT1);\n        }\n        else if (keyword === 'Unshaded' || keyword === 'SphereEnvMap' || keyword === 'TwoSided' ||\n            keyword === 'Unfogged' || keyword === 'NoDepthTest' || keyword === 'NoDepthSet') {\n            res.Shading |= _model__WEBPACK_IMPORTED_MODULE_0__.LayerShading[keyword];\n        }\n        else if (keyword === 'FilterMode') {\n            var val = parseKeyword(state);\n            if (val === 'None' || val === 'Transparent' || val === 'Blend' || val === 'Additive' ||\n                val === 'AddAlpha' || val === 'Modulate' || val === 'Modulate2x') {\n                res.FilterMode = _model__WEBPACK_IMPORTED_MODULE_0__.FilterMode[val];\n            }\n        }\n        else if (keyword === 'TVertexAnimId') {\n            res.TVertexAnimId = parseNumber(state);\n        }\n        else if (model.Version >= 900 && keyword === 'EmissiveGain') {\n            if (isStatic) {\n                res[keyword] = parseNumber(state);\n            }\n            else {\n                res[keyword] = parseAnimVector(state, AnimVectorType.FLOAT1);\n            }\n        }\n        else if (model.Version >= 1000 && keyword === 'FresnelColor') {\n            if (isStatic) {\n                var array = new Float32Array(3);\n                res[keyword] = parseArray(state, array, 0);\n            }\n            else {\n                res[keyword] = parseAnimVector(state, AnimVectorType.FLOAT3);\n            }\n        }\n        else if (model.Version >= 1000 && (keyword === 'FresnelOpacity' || keyword === 'FresnelTeamColor')) {\n            if (isStatic) {\n                res[keyword] = parseNumber(state);\n            }\n            else {\n                res[keyword] = parseAnimVector(state, AnimVectorType.FLOAT1);\n            }\n        }\n        else {\n            var val = parseNumber(state);\n            if (val === null) {\n                val = parseKeyword(state);\n            }\n            res[keyword] = val;\n        }\n        parseSymbol(state, ',');\n        parseComment(state);\n        parseSpace(state);\n    }\n    strictParseSymbol(state, '}');\n    return res;\n}\nfunction parseMaterials(state, model) {\n    var res = [];\n    parseNumber(state); // count, not used\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var obj = {\n            RenderMode: 0,\n            Layers: []\n        };\n        parseKeyword(state); // Material\n        strictParseSymbol(state, '{');\n        while (state.char() !== '}') {\n            var keyword = parseKeyword(state);\n            if (!keyword) {\n                throwError(state);\n            }\n            if (keyword === 'Layer') {\n                obj.Layers.push(parseLayer(state, model));\n            }\n            else if (keyword === 'PriorityPlane' || keyword === 'RenderMode') {\n                obj[keyword] = parseNumber(state);\n            }\n            else if (keyword === 'ConstantColor' || keyword === 'SortPrimsFarZ' || keyword === 'FullResolution') {\n                obj.RenderMode |= _model__WEBPACK_IMPORTED_MODULE_0__.MaterialRenderMode[keyword];\n            }\n            else if (model.Version >= 900 && model.Version <= 1100 && keyword === 'Shader') {\n                obj[keyword] = parseString(state);\n            }\n            else {\n                throw new Error('Unknown material property ' + keyword);\n            }\n            parseSymbol(state, ',');\n        }\n        strictParseSymbol(state, '}');\n        res.push(obj);\n    }\n    strictParseSymbol(state, '}');\n    model.Materials = res;\n}\nvar GeosetPartType;\n(function (GeosetPartType) {\n    GeosetPartType[GeosetPartType[\"INT\"] = 0] = \"INT\";\n    GeosetPartType[GeosetPartType[\"FLOAT\"] = 1] = \"FLOAT\";\n})(GeosetPartType || (GeosetPartType = {}));\nfunction parseGeosetPart(state, countPerObj, type) {\n    var count = parseNumber(state);\n    var arr = new (type === GeosetPartType.FLOAT ? Float32Array : Uint8Array)(count * countPerObj);\n    strictParseSymbol(state, '{');\n    for (var index = 0; index < count; ++index) {\n        parseArray(state, arr, index * countPerObj);\n        strictParseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    return arr;\n}\nfunction parseGeoset(state, model) {\n    var res = {\n        Vertices: null,\n        Normals: null,\n        TVertices: [],\n        VertexGroup: new Uint8Array(0),\n        Faces: null,\n        Groups: null,\n        TotalGroupsCount: null,\n        MinimumExtent: null,\n        MaximumExtent: null,\n        BoundsRadius: 0,\n        Anims: [],\n        MaterialID: null,\n        SelectionGroup: null,\n        Unselectable: false\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'Vertices' || keyword === 'Normals' || keyword === 'TVertices') {\n            var countPerObj = 3;\n            if (keyword === 'TVertices') {\n                countPerObj = 2;\n            }\n            var arr = parseGeosetPart(state, countPerObj, GeosetPartType.FLOAT);\n            if (keyword === 'TVertices') {\n                res.TVertices.push(arr);\n            }\n            else {\n                res[keyword] = arr;\n            }\n        }\n        else if (keyword === 'VertexGroup') {\n            res[keyword] = new Uint8Array(res.Vertices.length / 3);\n            parseArray(state, res[keyword], 0);\n        }\n        else if (keyword === 'Faces') {\n            var groupCount = parseNumber(state); // group count, always 1 in the official models\n            var indexCount = parseNumber(state);\n            var pos = 0;\n            res.Faces = new Uint16Array(indexCount);\n            strictParseSymbol(state, '{');\n            var keyword_1 = parseKeyword(state);\n            if (keyword_1 !== 'Triangles') {\n                throwError(state, 'unexpected faces type');\n            }\n            strictParseSymbol(state, '{');\n            for (var g = 0; g < groupCount; ++g) {\n                var count = parseArrayCounted(state, res.Faces, pos);\n                if (!count) {\n                    throwError(state, 'expected array');\n                }\n                pos += count;\n                parseSymbol(state, ',');\n            }\n            if (pos !== indexCount || indexCount % 3 !== 0) {\n                throwError(state, 'mismatched faces array');\n            }\n            strictParseSymbol(state, '}');\n            strictParseSymbol(state, '}');\n        }\n        else if (keyword === 'Groups') {\n            var groups = [];\n            parseNumber(state); // groups count, unused\n            res.TotalGroupsCount = parseNumber(state); // summed in subarrays\n            strictParseSymbol(state, '{');\n            while (state.char() !== '}') {\n                parseKeyword(state); // Matrices\n                groups.push(parseArray(state));\n                parseSymbol(state, ',');\n            }\n            strictParseSymbol(state, '}');\n            res.Groups = groups;\n        }\n        else if (keyword === 'MinimumExtent' || keyword === 'MaximumExtent') {\n            var arr = new Float32Array(3);\n            res[keyword] = parseArray(state, arr, 0);\n            strictParseSymbol(state, ',');\n        }\n        else if (keyword === 'BoundsRadius' || keyword === 'MaterialID' || keyword === 'SelectionGroup') {\n            res[keyword] = parseNumber(state);\n            strictParseSymbol(state, ',');\n        }\n        else if (keyword === 'Anim') {\n            var _a = parseObject(state), _unused = _a[0], obj = _a[1];\n            if (obj.Alpha === undefined) {\n                obj.Alpha = 1;\n            }\n            res.Anims.push(obj);\n        }\n        else if (keyword === 'Unselectable') {\n            res.Unselectable = true;\n            strictParseSymbol(state, ',');\n        }\n        else if (model.Version >= 900) {\n            if (keyword === 'LevelOfDetail') {\n                res.LevelOfDetail = parseNumber(state);\n                strictParseSymbol(state, ',');\n            }\n            else if (keyword === 'Name') {\n                res.Name = parseString(state);\n                strictParseSymbol(state, ',');\n            }\n            else if (keyword === 'Tangents') {\n                res.Tangents = parseGeosetPart(state, 4, GeosetPartType.FLOAT);\n            }\n            else if (keyword === 'SkinWeights') {\n                res.SkinWeights = parseGeosetPart(state, 8, GeosetPartType.INT);\n            }\n        }\n    }\n    strictParseSymbol(state, '}');\n    model.Geosets.push(res);\n}\nfunction parseGeosetAnim(state, model) {\n    var res = {\n        GeosetId: -1,\n        Alpha: 1,\n        Color: null,\n        Flags: 0\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        var isStatic = false;\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'static') {\n            isStatic = true;\n            keyword = parseKeyword(state);\n        }\n        if (keyword === 'Alpha') {\n            if (isStatic) {\n                res.Alpha = parseNumber(state);\n            }\n            else {\n                res.Alpha = parseAnimVector(state, AnimVectorType.FLOAT1);\n            }\n        }\n        else if (keyword === 'Color') {\n            if (isStatic) {\n                var array = new Float32Array(3);\n                res.Color = parseArray(state, array, 0);\n                res.Color.reverse();\n            }\n            else {\n                res.Color = parseAnimVector(state, AnimVectorType.FLOAT3);\n                for (var _i = 0, _a = res.Color.Keys; _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    key.Vector.reverse();\n                    if (key.InTan) {\n                        key.InTan.reverse();\n                        key.OutTan.reverse();\n                    }\n                }\n            }\n        }\n        else if (keyword === 'DropShadow') {\n            res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.GeosetAnimFlags[keyword];\n        }\n        else {\n            res[keyword] = parseNumber(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.GeosetAnims.push(res);\n}\nfunction parseNode(state, type, model) {\n    var name = parseString(state);\n    var node = {\n        Name: name,\n        ObjectId: null,\n        Parent: null,\n        PivotPoint: null,\n        Flags: _model__WEBPACK_IMPORTED_MODULE_0__.NodeType[type]\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'Visibility') {\n            var vectorType = AnimVectorType.FLOAT3;\n            if (keyword === 'Rotation') {\n                vectorType = AnimVectorType.FLOAT4;\n            }\n            else if (keyword === 'Visibility') {\n                vectorType = AnimVectorType.FLOAT1;\n            }\n            node[keyword] = parseAnimVector(state, vectorType);\n        }\n        else if (keyword === 'BillboardedLockZ' || keyword === 'BillboardedLockY' || keyword === 'BillboardedLockX' ||\n            keyword === 'Billboarded' || keyword === 'CameraAnchored') {\n            node.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags[keyword];\n        }\n        else if (keyword === 'DontInherit') {\n            strictParseSymbol(state, '{');\n            var val = parseKeyword(state);\n            if (val === 'Translation') {\n                node.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritTranslation;\n            }\n            else if (val === 'Rotation') {\n                node.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritRotation;\n            }\n            else if (val === 'Scaling') {\n                node.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritScaling;\n            }\n            strictParseSymbol(state, '}');\n        }\n        else if (keyword === 'Path') {\n            node[keyword] = parseString(state);\n        }\n        else {\n            var val = parseKeyword(state) || parseNumber(state);\n            if (keyword === 'GeosetId' && val === 'Multiple' ||\n                keyword === 'GeosetAnimId' && val === 'None') {\n                val = null;\n            }\n            node[keyword] = val;\n        }\n        parseSymbol(state, ',');\n        parseComment(state);\n        parseSpace(state);\n    }\n    strictParseSymbol(state, '}');\n    model.Nodes[node.ObjectId] = node;\n    return node;\n}\nfunction parseBone(state, model) {\n    var node = parseNode(state, 'Bone', model);\n    model.Bones.push(node);\n}\nfunction parseHelper(state, model) {\n    var node = parseNode(state, 'Helper', model);\n    model.Helpers.push(node);\n}\nfunction parseAttachment(state, model) {\n    var node = parseNode(state, 'Attachment', model);\n    model.Attachments.push(node);\n}\nfunction parsePivotPoints(state, model) {\n    var count = parseNumber(state);\n    var res = [];\n    strictParseSymbol(state, '{');\n    for (var i = 0; i < count; ++i) {\n        res.push(parseArray(state, new Float32Array(3), 0));\n        strictParseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.PivotPoints = res;\n}\nfunction parseEventObject(state, model) {\n    var name = parseString(state);\n    var res = {\n        Name: name,\n        ObjectId: null,\n        Parent: null,\n        PivotPoint: null,\n        EventTrack: null,\n        Flags: _model__WEBPACK_IMPORTED_MODULE_0__.NodeType.EventObject\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'EventTrack') {\n            var count = parseNumber(state); // EventTrack count\n            res.EventTrack = parseArray(state, new Uint32Array(count), 0);\n        }\n        else if (keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling') {\n            var type = keyword === 'Rotation' ? AnimVectorType.FLOAT4 : AnimVectorType.FLOAT3;\n            res[keyword] = parseAnimVector(state, type);\n        }\n        else {\n            res[keyword] = parseNumber(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.EventObjects.push(res);\n    model.Nodes[res.ObjectId] = res;\n}\nfunction parseCollisionShape(state, model) {\n    var name = parseString(state);\n    var res = {\n        Name: name,\n        ObjectId: null,\n        Parent: null,\n        PivotPoint: null,\n        Shape: _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Box,\n        Vertices: null,\n        Flags: _model__WEBPACK_IMPORTED_MODULE_0__.NodeType.CollisionShape\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'Sphere') {\n            res.Shape = _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Sphere;\n        }\n        else if (keyword === 'Box') {\n            res.Shape = _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Box;\n        }\n        else if (keyword === 'Vertices') {\n            var count = parseNumber(state);\n            var vertices = new Float32Array(count * 3);\n            strictParseSymbol(state, '{');\n            for (var i = 0; i < count; ++i) {\n                parseArray(state, vertices, i * 3);\n                strictParseSymbol(state, ',');\n            }\n            strictParseSymbol(state, '}');\n            res.Vertices = vertices;\n        }\n        else if (keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling') {\n            var type = keyword === 'Rotation' ? AnimVectorType.FLOAT4 : AnimVectorType.FLOAT3;\n            res[keyword] = parseAnimVector(state, type);\n        }\n        else {\n            res[keyword] = parseNumber(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.CollisionShapes.push(res);\n    model.Nodes[res.ObjectId] = res;\n}\nfunction parseGlobalSequences(state, model) {\n    var res = [];\n    var count = parseNumber(state);\n    strictParseSymbol(state, '{');\n    for (var i = 0; i < count; ++i) {\n        var keyword = parseKeyword(state);\n        if (keyword === 'Duration') {\n            res.push(parseNumber(state));\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.GlobalSequences = res;\n}\nfunction parseUnknownBlock(state) {\n    var opened;\n    while (state.char() !== undefined && state.char() !== '{') {\n        ++state.pos;\n    }\n    opened = 1;\n    ++state.pos;\n    while (state.char() !== undefined && opened > 0) {\n        if (state.char() === '{') {\n            ++opened;\n        }\n        else if (state.char() === '}') {\n            --opened;\n        }\n        ++state.pos;\n    }\n    parseSpace(state);\n}\nfunction parseParticleEmitter(state, model) {\n    var res = {\n        ObjectId: null,\n        Parent: null,\n        Name: null,\n        Flags: 0\n    };\n    res.Name = parseString(state);\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        var isStatic = false;\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'static') {\n            isStatic = true;\n            keyword = parseKeyword(state);\n        }\n        if (keyword === 'ObjectId' || keyword === 'Parent') {\n            res[keyword] = parseNumber(state);\n        }\n        else if (keyword === 'EmitterUsesMDL' || keyword === 'EmitterUsesTGA') {\n            res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterFlags[keyword];\n        }\n        else if (!isStatic && (keyword === 'Visibility' || keyword === 'Translation' || keyword === 'Rotation' ||\n            keyword === 'Scaling' || keyword === 'EmissionRate' || keyword === 'Gravity' || keyword === 'Longitude' ||\n            keyword === 'Latitude')) {\n            var type = AnimVectorType.FLOAT3;\n            if (keyword === 'Visibility' || keyword === 'EmissionRate' || keyword === 'Gravity' ||\n                keyword === 'Longitude' || keyword === 'Latitude') {\n                type = AnimVectorType.FLOAT1;\n            }\n            else if (keyword === 'Rotation') {\n                type = AnimVectorType.FLOAT4;\n            }\n            res[keyword] = parseAnimVector(state, type);\n        }\n        else if (keyword === 'Particle') {\n            strictParseSymbol(state, '{');\n            while (state.char() !== '}') {\n                var keyword2 = parseKeyword(state);\n                var isStatic2 = false;\n                if (keyword2 === 'static') {\n                    isStatic2 = true;\n                    keyword2 = parseKeyword(state);\n                }\n                if (!isStatic2 && (keyword2 === 'LifeSpan' || keyword2 === 'InitVelocity')) {\n                    res[keyword2] = parseAnimVector(state, AnimVectorType.FLOAT1);\n                }\n                else if (keyword2 === 'LifeSpan' || keyword2 === 'InitVelocity') {\n                    res[keyword2] = parseNumber(state);\n                }\n                else if (keyword2 === 'Path') {\n                    res.Path = parseString(state);\n                }\n                parseSymbol(state, ',');\n            }\n            strictParseSymbol(state, '}');\n        }\n        else {\n            res[keyword] = parseNumber(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.ParticleEmitters.push(res);\n}\nfunction parseParticleEmitter2(state, model) {\n    var name = parseString(state);\n    var res = {\n        Name: name,\n        ObjectId: null,\n        Parent: null,\n        PivotPoint: null,\n        Flags: _model__WEBPACK_IMPORTED_MODULE_0__.NodeType.ParticleEmitter,\n        FrameFlags: 0\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        var isStatic = false;\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'static') {\n            isStatic = true;\n            keyword = parseKeyword(state);\n        }\n        if (!isStatic && (keyword === 'Speed' || keyword === 'Latitude' || keyword === 'Visibility' ||\n            keyword === 'EmissionRate' || keyword === 'Width' || keyword === 'Length' || keyword === 'Translation' ||\n            keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'Gravity' || keyword === 'Variation')) {\n            var type = AnimVectorType.FLOAT3;\n            switch (keyword) {\n                case 'Rotation':\n                    type = AnimVectorType.FLOAT4;\n                    break;\n                case 'Speed':\n                case 'Latitude':\n                case 'Visibility':\n                case 'EmissionRate':\n                case 'Width':\n                case 'Length':\n                case 'Gravity':\n                case 'Variation':\n                    type = AnimVectorType.FLOAT1;\n                    break;\n            }\n            res[keyword] = parseAnimVector(state, type);\n        }\n        else if (keyword === 'Variation' || keyword === 'Gravity' || keyword === 'ReplaceableId' || keyword === 'PriorityPlane') {\n            res[keyword] = parseNumber(state);\n        }\n        else if (keyword === 'SortPrimsFarZ' || keyword === 'Unshaded' || keyword === 'LineEmitter' ||\n            keyword === 'Unfogged' || keyword === 'ModelSpace' || keyword === 'XYQuad') {\n            res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2Flags[keyword];\n        }\n        else if (keyword === 'Both') {\n            res.FrameFlags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Head | _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Tail;\n        }\n        else if (keyword === 'Head' || keyword === 'Tail') {\n            res.FrameFlags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags[keyword];\n        }\n        else if (keyword === 'Squirt') {\n            res[keyword] = true;\n        }\n        else if (keyword === 'DontInherit') {\n            strictParseSymbol(state, '{');\n            var val = parseKeyword(state);\n            if (val === 'Translation') {\n                res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritTranslation;\n            }\n            else if (val === 'Rotation') {\n                res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritRotation;\n            }\n            else if (val === 'Scaling') {\n                res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.NodeFlags.DontInheritScaling;\n            }\n            strictParseSymbol(state, '}');\n        }\n        else if (keyword === 'SegmentColor') {\n            var colors = [];\n            strictParseSymbol(state, '{');\n            while (state.char() !== '}') {\n                parseKeyword(state); // Color\n                var colorArr = new Float32Array(3);\n                parseArray(state, colorArr, 0);\n                // bgr order, inverse from mdx\n                var temp = colorArr[0];\n                colorArr[0] = colorArr[2];\n                colorArr[2] = temp;\n                colors.push(colorArr);\n                parseSymbol(state, ',');\n            }\n            strictParseSymbol(state, '}');\n            res.SegmentColor = colors;\n        }\n        else if (keyword === 'Alpha') {\n            res.Alpha = new Uint8Array(3);\n            parseArray(state, res.Alpha, 0);\n        }\n        else if (keyword === 'ParticleScaling') {\n            res[keyword] = new Float32Array(3);\n            parseArray(state, res[keyword], 0);\n        }\n        else if (keyword === 'LifeSpanUVAnim' || keyword === 'DecayUVAnim' || keyword === 'TailUVAnim' ||\n            keyword === 'TailDecayUVAnim') {\n            res[keyword] = new Uint32Array(3);\n            parseArray(state, res[keyword], 0);\n        }\n        else if (keyword === 'Transparent' || keyword === 'Blend' || keyword === 'Additive' ||\n            keyword === 'AlphaKey' || keyword === 'Modulate' || keyword === 'Modulate2x') {\n            res.FilterMode = _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FilterMode[keyword];\n        }\n        else {\n            res[keyword] = parseNumber(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.ParticleEmitters2.push(res);\n    model.Nodes[res.ObjectId] = res;\n}\nfunction parseCamera(state, model) {\n    var res = {\n        Name: null,\n        Position: null,\n        FieldOfView: 0,\n        NearClip: 0,\n        FarClip: 0,\n        TargetPosition: null\n    };\n    res.Name = parseString(state);\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'Position') {\n            res.Position = new Float32Array(3);\n            parseArray(state, res.Position, 0);\n        }\n        else if (keyword === 'FieldOfView' || keyword === 'NearClip' || keyword === 'FarClip') {\n            res[keyword] = parseNumber(state);\n        }\n        else if (keyword === 'Target') {\n            strictParseSymbol(state, '{');\n            while (state.char() !== '}') {\n                var keyword2 = parseKeyword(state);\n                if (keyword2 === 'Position') {\n                    res.TargetPosition = new Float32Array(3);\n                    parseArray(state, res.TargetPosition, 0);\n                }\n                else if (keyword2 === 'Translation') {\n                    res.TargetTranslation = parseAnimVector(state, AnimVectorType.FLOAT3);\n                }\n                parseSymbol(state, ',');\n            }\n            strictParseSymbol(state, '}');\n        }\n        else if (keyword === 'Translation' || keyword === 'Rotation') {\n            res[keyword] = parseAnimVector(state, keyword === 'Rotation' ?\n                AnimVectorType.FLOAT1 :\n                AnimVectorType.FLOAT3);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.Cameras.push(res);\n}\nfunction parseLight(state, model) {\n    var name = parseString(state);\n    var res = {\n        Name: name,\n        ObjectId: null,\n        Parent: null,\n        PivotPoint: null,\n        Flags: _model__WEBPACK_IMPORTED_MODULE_0__.NodeType.Light,\n        LightType: 0\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        var isStatic = false;\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'static') {\n            isStatic = true;\n            keyword = parseKeyword(state);\n        }\n        if (!isStatic && (keyword === 'Visibility' || keyword === 'Color' || keyword === 'Intensity' ||\n            keyword === 'AmbIntensity' || keyword === 'AmbColor' || keyword === 'Translation' ||\n            keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'AttenuationStart' ||\n            keyword === 'AttenuationEnd')) {\n            var type = AnimVectorType.FLOAT3;\n            switch (keyword) {\n                case 'Rotation':\n                    type = AnimVectorType.FLOAT4;\n                    break;\n                case 'Visibility':\n                case 'Intensity':\n                case 'AmbIntensity':\n                case 'AttenuationStart':\n                case 'AttenuationEnd':\n                    type = AnimVectorType.FLOAT1;\n                    break;\n            }\n            res[keyword] = parseAnimVector(state, type);\n            if (keyword === 'Color' || keyword === 'AmbColor') {\n                for (var _i = 0, _a = res[keyword].Keys; _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    key.Vector.reverse();\n                    if (key.InTan) {\n                        key.InTan.reverse();\n                        key.OutTan.reverse();\n                    }\n                }\n            }\n        }\n        else if (keyword === 'Omnidirectional' || keyword === 'Directional' || keyword === 'Ambient') {\n            res.LightType = _model__WEBPACK_IMPORTED_MODULE_0__.LightType[keyword];\n        }\n        else if (keyword === 'Color' || keyword === 'AmbColor') {\n            var color = new Float32Array(3);\n            parseArray(state, color, 0);\n            // bgr order, inverse from mdx\n            var temp = color[0];\n            color[0] = color[2];\n            color[2] = temp;\n            res[keyword] = color;\n        }\n        else {\n            res[keyword] = parseNumber(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.Lights.push(res);\n    model.Nodes[res.ObjectId] = res;\n}\nfunction parseTextureAnims(state, model) {\n    var res = [];\n    parseNumber(state); // count, not used\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var obj = {};\n        parseKeyword(state); // TVertexAnim\n        strictParseSymbol(state, '{');\n        while (state.char() !== '}') {\n            var keyword = parseKeyword(state);\n            if (!keyword) {\n                throwError(state);\n            }\n            if (keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling') {\n                var type = keyword === 'Rotation' ? AnimVectorType.FLOAT4 : AnimVectorType.FLOAT3;\n                obj[keyword] = parseAnimVector(state, type);\n            }\n            else {\n                throw new Error('Unknown texture anim property ' + keyword);\n            }\n            parseSymbol(state, ',');\n        }\n        strictParseSymbol(state, '}');\n        res.push(obj);\n    }\n    strictParseSymbol(state, '}');\n    model.TextureAnims = res;\n}\nfunction parseRibbonEmitter(state, model) {\n    var name = parseString(state);\n    var res = {\n        Name: name,\n        ObjectId: null,\n        Parent: null,\n        PivotPoint: null,\n        Flags: _model__WEBPACK_IMPORTED_MODULE_0__.NodeType.RibbonEmitter,\n        HeightAbove: null,\n        HeightBelow: null,\n        Alpha: null,\n        Color: null,\n        LifeSpan: null,\n        TextureSlot: null,\n        EmissionRate: null,\n        Rows: null,\n        Columns: null,\n        MaterialID: 0,\n        Gravity: null,\n        Visibility: null\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        var isStatic = false;\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'static') {\n            isStatic = true;\n            keyword = parseKeyword(state);\n        }\n        if (!isStatic && (keyword === 'Visibility' || keyword === 'HeightAbove' || keyword === 'HeightBelow' ||\n            keyword === 'Translation' || keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'Alpha' ||\n            keyword === 'TextureSlot')) {\n            var type = AnimVectorType.FLOAT3;\n            switch (keyword) {\n                case 'Rotation':\n                    type = AnimVectorType.FLOAT4;\n                    break;\n                case 'Visibility':\n                case 'HeightAbove':\n                case 'HeightBelow':\n                case 'Alpha':\n                    type = AnimVectorType.FLOAT1;\n                    break;\n                case 'TextureSlot':\n                    type = AnimVectorType.INT1;\n                    break;\n            }\n            res[keyword] = parseAnimVector(state, type);\n        }\n        else if (keyword === 'Color') {\n            var color = new Float32Array(3);\n            parseArray(state, color, 0);\n            // bgr order, inverse from mdx\n            var temp = color[0];\n            color[0] = color[2];\n            color[2] = temp;\n            res[keyword] = color;\n        }\n        else {\n            res[keyword] = parseNumber(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.RibbonEmitters.push(res);\n    model.Nodes[res.ObjectId] = res;\n}\nfunction parseFaceFX(state, model) {\n    if (model.Version < 900) {\n        throwError(state, 'Unexpected model chunk FaceFX');\n    }\n    var name = parseString(state);\n    var res = {\n        Name: name,\n        Path: ''\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'Path') {\n            res.Path = parseString(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.FaceFX = model.FaceFX || [];\n    model.FaceFX.push(res);\n}\nfunction parseBindPose(state, model) {\n    if (model.Version < 900) {\n        throwError(state, 'Unexpected model chunk BindPose');\n    }\n    var res = {\n        Matrices: []\n    };\n    strictParseSymbol(state, '{');\n    parseKeyword(state); // Matrices\n    var count = parseNumber(state);\n    strictParseSymbol(state, '{');\n    for (var i = 0; i < count; ++i) {\n        var matrix = new Float32Array(12);\n        parseArray(state, matrix, 0);\n        parseSymbol(state, ',');\n        res.Matrices.push(matrix);\n    }\n    strictParseSymbol(state, '}');\n    strictParseSymbol(state, '}');\n    model.BindPoses = model.BindPoses || [];\n    model.BindPoses.push(res);\n}\nfunction parseParticleEmitterPopcorn(state, model) {\n    if (model.Version < 900) {\n        throwError(state, 'Unexpected model chunk ParticleEmitterPopcorn');\n    }\n    var name = parseString(state);\n    var res = {\n        Name: name,\n        ObjectId: null,\n        Parent: null,\n        PivotPoint: null,\n        Flags: _model__WEBPACK_IMPORTED_MODULE_0__.NodeType.ParticleEmitter\n    };\n    strictParseSymbol(state, '{');\n    while (state.char() !== '}') {\n        var keyword = parseKeyword(state);\n        var isStatic = false;\n        if (!keyword) {\n            throwError(state);\n        }\n        if (keyword === 'static') {\n            isStatic = true;\n            keyword = parseKeyword(state);\n        }\n        if (!isStatic && (keyword === 'LifeSpan' || keyword === 'EmissionRate' || keyword === 'Speed' ||\n            keyword === 'Color' || keyword === 'Alpha' || keyword === 'Visibility' ||\n            keyword === 'Rotation' || keyword === 'Scaling' || keyword === 'Translation')) {\n            var type = AnimVectorType.FLOAT3;\n            switch (keyword) {\n                case 'LifeSpan':\n                case 'EmissionRate':\n                case 'Speed':\n                case 'Alpha':\n                case 'Visibility':\n                    type = AnimVectorType.FLOAT1;\n                    break;\n            }\n            res[keyword] = parseAnimVector(state, type);\n        }\n        else if (keyword === 'LifeSpan' || keyword === 'EmissionRate' || keyword === 'Speed' || keyword === 'Alpha') {\n            res[keyword] = parseNumber(state);\n        }\n        else if (keyword === 'Color') {\n            var array = new Float32Array(3);\n            res[keyword] = parseArray(state, array, 0);\n        }\n        else if (keyword === 'ReplaceableId') {\n            res[keyword] = parseNumber(state);\n        }\n        else if (keyword === 'Path' || keyword === 'AnimVisibilityGuide') {\n            res[keyword] = parseString(state);\n        }\n        else if (keyword === 'Unshaded' || keyword === 'SortPrimsFarZ' || keyword === 'Unfogged') {\n            if (keyword === 'Unshaded') {\n                res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterPopcornFlags.Unshaded;\n            }\n            else if (keyword === 'Unfogged') {\n                res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterPopcornFlags.Unfogged;\n            }\n            else if (keyword === 'SortPrimsFarZ') {\n                res.Flags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitterPopcornFlags.SortPrimsFarZ;\n            }\n        }\n        else {\n            res[keyword] = parseNumber(state);\n        }\n        parseSymbol(state, ',');\n    }\n    strictParseSymbol(state, '}');\n    model.ParticleEmitterPopcorns = model.ParticleEmitterPopcorns || [];\n    model.ParticleEmitterPopcorns.push(res);\n    model.Nodes[res.ObjectId] = res;\n}\nvar parsers = {\n    Version: parseVersion,\n    Model: parseModelInfo,\n    Sequences: parseSequences,\n    Textures: parseTextures,\n    Materials: parseMaterials,\n    Geoset: parseGeoset,\n    GeosetAnim: parseGeosetAnim,\n    Bone: parseBone,\n    Helper: parseHelper,\n    Attachment: parseAttachment,\n    PivotPoints: parsePivotPoints,\n    EventObject: parseEventObject,\n    CollisionShape: parseCollisionShape,\n    GlobalSequences: parseGlobalSequences,\n    ParticleEmitter: parseParticleEmitter,\n    ParticleEmitter2: parseParticleEmitter2,\n    Camera: parseCamera,\n    Light: parseLight,\n    TextureAnims: parseTextureAnims,\n    RibbonEmitter: parseRibbonEmitter,\n    FaceFX: parseFaceFX,\n    BindPose: parseBindPose,\n    ParticleEmitterPopcorn: parseParticleEmitterPopcorn\n};\nfunction parse(str) {\n    var state = new State(str);\n    var model = {\n        // default\n        Version: 800,\n        Info: {\n            Name: '',\n            MinimumExtent: null,\n            MaximumExtent: null,\n            BoundsRadius: 0,\n            BlendTime: 150\n        },\n        Sequences: [],\n        GlobalSequences: [],\n        Textures: [],\n        Materials: [],\n        TextureAnims: [],\n        Geosets: [],\n        GeosetAnims: [],\n        Bones: [],\n        Helpers: [],\n        Attachments: [],\n        EventObjects: [],\n        ParticleEmitters: [],\n        ParticleEmitters2: [],\n        Cameras: [],\n        Lights: [],\n        RibbonEmitters: [],\n        CollisionShapes: [],\n        PivotPoints: [],\n        Nodes: []\n    };\n    while (state.pos < state.str.length) {\n        while (parseComment(state))\n            ;\n        var keyword = parseKeyword(state);\n        if (keyword) {\n            if (keyword in parsers) {\n                parsers[keyword](state, model);\n            }\n            else {\n                parseUnknownBlock(state);\n            }\n        }\n        else {\n            break;\n        }\n    }\n    for (var i = 0; i < model.Nodes.length; ++i) {\n        if (model.PivotPoints[i]) {\n            model.Nodes[i].PivotPoint = model.PivotPoints[i];\n        }\n    }\n    return model;\n}\n\n\n//# sourceURL=webpack://war3-model/./mdl/parse.ts?");

/***/ }),

/***/ "./mdx/generate.ts":
/*!*************************!*\
  !*** ./mdx/generate.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model */ \"./model.ts\");\n/* harmony import */ var _renderer_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/util */ \"./renderer/util.ts\");\nvar _a;\n\n\nvar BIG_ENDIAN = true;\nvar NONE = -1;\nvar Stream = /** @class */ (function () {\n    function Stream(arrayBuffer) {\n        this.ab = arrayBuffer;\n        this.uint = new Uint8Array(this.ab);\n        this.view = new DataView(this.ab);\n        this.pos = 0;\n    }\n    Stream.prototype.keyword = function (keyword) {\n        this.uint[this.pos] = keyword.charCodeAt(0);\n        this.uint[this.pos + 1] = keyword.charCodeAt(1);\n        this.uint[this.pos + 2] = keyword.charCodeAt(2);\n        this.uint[this.pos + 3] = keyword.charCodeAt(3);\n        this.pos += 4;\n    };\n    Stream.prototype.uint8 = function (num) {\n        this.view.setUint8(this.pos, num);\n        this.pos += 1;\n    };\n    Stream.prototype.uint16 = function (num) {\n        this.view.setUint16(this.pos, num, BIG_ENDIAN);\n        this.pos += 2;\n    };\n    Stream.prototype.int32 = function (num) {\n        this.view.setInt32(this.pos, num, BIG_ENDIAN);\n        this.pos += 4;\n    };\n    Stream.prototype.uint32 = function (num) {\n        this.view.setUint32(this.pos, num, BIG_ENDIAN);\n        this.pos += 4;\n    };\n    Stream.prototype.float32 = function (num) {\n        this.view.setFloat32(this.pos, num, BIG_ENDIAN);\n        this.pos += 4;\n    };\n    Stream.prototype.float32Array = function (arr) {\n        for (var i = 0; i < arr.length; ++i) {\n            this.float32(arr[i]);\n        }\n    };\n    Stream.prototype.uint8Array = function (arr) {\n        for (var i = 0; i < arr.length; ++i) {\n            this.uint8(arr[i]);\n        }\n    };\n    Stream.prototype.uint16Array = function (arr) {\n        for (var i = 0; i < arr.length; ++i) {\n            this.uint16(arr[i]);\n        }\n    };\n    Stream.prototype.int32Array = function (arr) {\n        for (var i = 0; i < arr.length; ++i) {\n            this.int32(arr[i]);\n        }\n    };\n    Stream.prototype.uint32Array = function (arr) {\n        for (var i = 0; i < arr.length; ++i) {\n            this.uint32(arr[i]);\n        }\n    };\n    Stream.prototype.str = function (str, len) {\n        for (var i = 0; i < len; ++i, ++this.pos) {\n            this.uint[this.pos] = i < str.length ? str.charCodeAt(i) : 0;\n        }\n    };\n    Stream.prototype.animVector = function (animVector, type) {\n        var isInt = type === AnimVectorType.INT1;\n        this.int32(animVector.Keys.length);\n        this.int32(animVector.LineType);\n        this.int32(animVector.GlobalSeqId !== null ? animVector.GlobalSeqId : NONE);\n        for (var _i = 0, _a = animVector.Keys; _i < _a.length; _i++) {\n            var keyFrame = _a[_i];\n            this.int32(keyFrame.Frame);\n            if (isInt) {\n                this.int32Array(keyFrame.Vector);\n            }\n            else {\n                this.float32Array(keyFrame.Vector);\n            }\n            if (animVector.LineType === _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Hermite || animVector.LineType === _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Bezier) {\n                if (isInt) {\n                    this.int32Array(keyFrame.InTan);\n                    this.int32Array(keyFrame.OutTan);\n                }\n                else {\n                    this.float32Array(keyFrame.InTan);\n                    this.float32Array(keyFrame.OutTan);\n                }\n            }\n        }\n    };\n    return Stream;\n}());\nfunction generateExtent(obj, stream) {\n    stream.float32(obj.BoundsRadius || 0);\n    for (var _i = 0, _a = ['MinimumExtent', 'MaximumExtent']; _i < _a.length; _i++) {\n        var key = _a[_i];\n        stream.float32Array(obj[key]);\n    }\n}\nvar AnimVectorType;\n(function (AnimVectorType) {\n    AnimVectorType[AnimVectorType[\"INT1\"] = 0] = \"INT1\";\n    AnimVectorType[AnimVectorType[\"FLOAT1\"] = 1] = \"FLOAT1\";\n    AnimVectorType[AnimVectorType[\"FLOAT3\"] = 2] = \"FLOAT3\";\n    AnimVectorType[AnimVectorType[\"FLOAT4\"] = 3] = \"FLOAT4\";\n})(AnimVectorType || (AnimVectorType = {}));\nvar animVectorSize = (_a = {},\n    _a[AnimVectorType.INT1] = 1,\n    _a[AnimVectorType.FLOAT1] = 1,\n    _a[AnimVectorType.FLOAT3] = 3,\n    _a[AnimVectorType.FLOAT4] = 4,\n    _a);\nfunction byteLengthAnimVector(animVector, type) {\n    return 4 /* key count */ +\n        4 /* LineType */ +\n        4 /* GlobalSeqId */ +\n        animVector.Keys.length * (4 /* frame */ +\n            4 * animVectorSize[type] *\n                (animVector.LineType === _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Hermite || animVector.LineType === _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Bezier ? 3 : 1));\n}\nfunction sum(arr) {\n    return arr.reduce(function (a, b) {\n        return a + b;\n    }, 0);\n}\nfunction byteLengthVersion() {\n    return 4 /* keyword */ +\n        4 /* size */ +\n        4 /* version */;\n}\nfunction generateVersion(model, stream) {\n    stream.keyword('VERS');\n    stream.int32(4);\n    stream.int32(model.Version);\n}\nvar MODEL_NAME_LENGTH = 0x150;\nfunction byteLengthModelInfo() {\n    return 4 /* keyword */ +\n        4 /* size */ +\n        MODEL_NAME_LENGTH +\n        4 /* 4-byte zero ? */ +\n        4 * 7 /* extent */ +\n        4; /* blend time */\n}\nfunction generateModelInfo(model, stream) {\n    stream.keyword('MODL');\n    stream.int32(byteLengthModelInfo() - 8);\n    stream.str(model.Info.Name, MODEL_NAME_LENGTH);\n    stream.int32(0);\n    generateExtent(model.Info, stream);\n    stream.int32(model.Info.BlendTime);\n}\nvar MODEL_SEQUENCE_NAME_LENGTH = 0x50;\nfunction byteLengthSequence() {\n    return MODEL_SEQUENCE_NAME_LENGTH +\n        4 * 2 /* interval */ +\n        4 /* MoveSpeed */ +\n        4 /* NonLooping */ +\n        4 /* Rarity */ +\n        4 +\n        4 * 7; /* extent */\n}\nfunction byteLengthSequences(model) {\n    if (!model.Sequences.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Sequences.map(byteLengthSequence));\n}\nfunction generateSequences(model, stream) {\n    if (!model.Sequences.length) {\n        return;\n    }\n    stream.keyword('SEQS');\n    stream.int32(byteLengthSequences(model) - 8);\n    for (var _i = 0, _a = model.Sequences; _i < _a.length; _i++) {\n        var sequence = _a[_i];\n        stream.str(sequence.Name, MODEL_SEQUENCE_NAME_LENGTH);\n        stream.int32(sequence.Interval[0]);\n        stream.int32(sequence.Interval[1]);\n        stream.float32(sequence.MoveSpeed);\n        stream.int32(sequence.NonLooping ? 1 : 0);\n        stream.float32(sequence.Rarity);\n        stream.int32(0);\n        generateExtent(sequence, stream);\n    }\n}\nfunction byteLengthGlobalSequences(model) {\n    if (!model.GlobalSequences || !model.GlobalSequences.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        4 * model.GlobalSequences.length;\n}\nfunction generateGlobalSequences(model, stream) {\n    if (!model.GlobalSequences || !model.GlobalSequences.length) {\n        return;\n    }\n    stream.keyword('GLBS');\n    stream.int32(model.GlobalSequences.length * 4);\n    for (var _i = 0, _a = model.GlobalSequences; _i < _a.length; _i++) {\n        var duration = _a[_i];\n        stream.int32(duration);\n    }\n}\nfunction byteLengthLayer(model, layer) {\n    return 4 /* size */ +\n        4 /* FilterMode */ +\n        4 /* Shading */ +\n        4 /* static TextureID */ +\n        4 /* TVertexAnimId */ +\n        4 +\n        4 /* static Alpha */ +\n        (model.Version >= 900 ? 4 : 0) /* EmissiveGain */ +\n        (model.Version >= 1000 ?\n            4 * 3 /* FresnelColor */ +\n                4 /* FresnelOpacity */ +\n                4 /* FresnelTeamColor */ :\n            0) +\n        (model.Version >= 1100 ?\n            4 /* ShaderTypeId */ +\n                4 /* textureCount */ +\n                _renderer_util__WEBPACK_IMPORTED_MODULE_1__.LAYER_TEXTURE_ID_MAP.reduce(function (acc, name) {\n                    return acc + (typeof layer[name] !== 'undefined' ?\n                        4 /* textureId */ +\n                            4 /* textureType */ +\n                            (typeof layer[name] === 'object' ?\n                                4 /* keyword */ + byteLengthAnimVector(layer[name], AnimVectorType.INT1) :\n                                0) :\n                        0);\n                }, 0) :\n            0) +\n        (layer.Alpha !== null && typeof layer.Alpha !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(layer.Alpha, AnimVectorType.FLOAT1) :\n            0) +\n        (model.Version < 1100 && layer.TextureID !== null && typeof layer.TextureID !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(layer.TextureID, AnimVectorType.INT1) :\n            0) +\n        (model.Version >= 900 && layer.EmissiveGain !== undefined && layer.EmissiveGain !== null && typeof layer.EmissiveGain !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(layer.EmissiveGain, AnimVectorType.FLOAT1) :\n            0) +\n        (model.Version >= 1000 && layer.FresnelColor !== undefined && layer.FresnelColor !== null && !(layer.FresnelColor instanceof Float32Array) ?\n            4 /* keyword */ + byteLengthAnimVector(layer.FresnelColor, AnimVectorType.FLOAT3) :\n            0) +\n        (model.Version >= 1000 && layer.FresnelOpacity !== undefined && layer.FresnelOpacity !== null && typeof layer.FresnelOpacity !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(layer.FresnelOpacity, AnimVectorType.FLOAT1) :\n            0) +\n        (model.Version >= 1000 && layer.FresnelTeamColor !== undefined && layer.FresnelTeamColor !== null && typeof layer.FresnelTeamColor !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(layer.FresnelTeamColor, AnimVectorType.FLOAT1) :\n            0);\n}\nfunction byteLengthMaterial(model, material) {\n    return 4 /* size */ +\n        4 /* PriorityPlane */ +\n        4 /* RenderMode */ +\n        4 /* LAYS keyword */ +\n        4 /* layer count */ +\n        (model.Version >= 900 && model.Version < 1100 ? 80 : 0) /* Shader */ +\n        sum(material.Layers.map(function (layer) { return byteLengthLayer(model, layer); }));\n}\nfunction byteLengthMaterials(model) {\n    if (!model.Materials.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Materials.map(function (material) { return byteLengthMaterial(model, material); }));\n}\nfunction generateMaterials(model, stream) {\n    if (!model.Materials.length) {\n        return;\n    }\n    stream.keyword('MTLS');\n    stream.int32(byteLengthMaterials(model) - 8);\n    for (var _i = 0, _a = model.Materials; _i < _a.length; _i++) {\n        var material = _a[_i];\n        stream.int32(byteLengthMaterial(model, material));\n        stream.int32(material.PriorityPlane);\n        stream.int32(material.RenderMode);\n        if (model.Version >= 900 && model.Version < 1100) {\n            stream.str(material.Shader || '', 80);\n        }\n        stream.keyword('LAYS');\n        stream.int32(material.Layers.length);\n        var _loop_1 = function (layer) {\n            stream.int32(byteLengthLayer(model, layer));\n            stream.int32(layer.FilterMode);\n            stream.int32(layer.Shading);\n            stream.int32(model.Version < 1100 && typeof layer.TextureID === 'number' ? layer.TextureID : 0);\n            stream.int32(layer.TVertexAnimId !== null ? layer.TVertexAnimId : NONE);\n            stream.int32(layer.CoordId);\n            stream.float32(typeof layer.Alpha === 'number' ? layer.Alpha : 1);\n            if (model.Version >= 900) {\n                stream.float32(typeof layer.EmissiveGain === 'number' ? layer.EmissiveGain : 1);\n                if (model.Version >= 1000) {\n                    stream.float32Array(layer.FresnelColor instanceof Float32Array ? layer.FresnelColor : new Float32Array([1, 1, 1]));\n                    stream.float32(typeof layer.FresnelOpacity === 'number' ? layer.FresnelOpacity : 0);\n                    stream.float32(typeof layer.FresnelTeamColor === 'number' ? layer.FresnelTeamColor : 0);\n                }\n            }\n            if (model.Version >= 1100) {\n                stream.int32(layer.ShaderTypeId || 0);\n                var textures = _renderer_util__WEBPACK_IMPORTED_MODULE_1__.LAYER_TEXTURE_ID_MAP.filter(function (name) { return layer[name] !== undefined; }).length;\n                stream.int32(textures);\n                for (var i = 0; i < _renderer_util__WEBPACK_IMPORTED_MODULE_1__.LAYER_TEXTURE_ID_MAP.length; ++i) {\n                    var id = layer[_renderer_util__WEBPACK_IMPORTED_MODULE_1__.LAYER_TEXTURE_ID_MAP[i]];\n                    if (id === undefined) {\n                        continue;\n                    }\n                    stream.int32(typeof id === 'number' ? id : 0);\n                    stream.int32(typeof id === 'number' ? i : 0); // ?\n                    if (typeof id === 'object') {\n                        stream.keyword('KMTF');\n                        stream.animVector(id, AnimVectorType.INT1);\n                    }\n                }\n            }\n            if (layer.Alpha && typeof layer.Alpha !== 'number') {\n                stream.keyword('KMTA');\n                stream.animVector(layer.Alpha, AnimVectorType.FLOAT1);\n            }\n            if (model.Version < 1100 && layer.TextureID && typeof layer.TextureID !== 'number') {\n                stream.keyword('KMTF');\n                stream.animVector(layer.TextureID, AnimVectorType.INT1);\n            }\n            if (model.Version >= 900 && layer.EmissiveGain && typeof layer.EmissiveGain !== 'number') {\n                stream.keyword('KMTE');\n                stream.animVector(layer.EmissiveGain, AnimVectorType.FLOAT1);\n            }\n            if (model.Version >= 1000 && layer.FresnelColor && !(layer.FresnelColor instanceof Float32Array)) {\n                stream.keyword('KFC3');\n                stream.animVector(layer.FresnelColor, AnimVectorType.FLOAT3);\n            }\n            if (model.Version >= 1000 && layer.FresnelOpacity && typeof layer.FresnelOpacity !== 'number') {\n                stream.keyword('KFCA');\n                stream.animVector(layer.FresnelOpacity, AnimVectorType.FLOAT1);\n            }\n            if (model.Version >= 1000 && layer.FresnelTeamColor && typeof layer.FresnelTeamColor !== 'number') {\n                stream.keyword('KFTC');\n                stream.animVector(layer.FresnelTeamColor, AnimVectorType.FLOAT1);\n            }\n        };\n        for (var _b = 0, _c = material.Layers; _b < _c.length; _b++) {\n            var layer = _c[_b];\n            _loop_1(layer);\n        }\n    }\n}\nvar MODEL_TEXTURE_PATH_LENGTH = 0x100;\nfunction byteLengthTexture() {\n    return 4 /* ReplaceableId */ +\n        MODEL_TEXTURE_PATH_LENGTH +\n        4 /* str trailing zero ? */ +\n        4 /* Flags */;\n}\nfunction byteLengthTextures(model) {\n    if (!model.Textures.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Textures.map(function (_texture) { return byteLengthTexture(); }));\n}\nfunction generateTextures(model, stream) {\n    if (!model.Textures.length) {\n        return;\n    }\n    stream.keyword('TEXS');\n    stream.int32(byteLengthTextures(model) - 8);\n    for (var _i = 0, _a = model.Textures; _i < _a.length; _i++) {\n        var texture = _a[_i];\n        stream.int32(texture.ReplaceableId);\n        stream.str(texture.Image, MODEL_TEXTURE_PATH_LENGTH);\n        stream.int32(0);\n        stream.int32(texture.Flags);\n    }\n}\nfunction byteLengthTextureAnim(anim) {\n    return 4 /* size */ +\n        (anim.Translation ? 4 /* keyword */ + byteLengthAnimVector(anim.Translation, AnimVectorType.FLOAT3) : 0) +\n        (anim.Rotation ? 4 /* keyword */ + byteLengthAnimVector(anim.Rotation, AnimVectorType.FLOAT4) : 0) +\n        (anim.Scaling ? 4 /* keyword */ + byteLengthAnimVector(anim.Scaling, AnimVectorType.FLOAT3) : 0);\n}\nfunction byteLengthTextureAnims(model) {\n    if (!model.TextureAnims || !model.TextureAnims.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.TextureAnims.map(function (anim) { return byteLengthTextureAnim(anim); }));\n}\nfunction generateTextureAnims(model, stream) {\n    if (!model.TextureAnims || !model.TextureAnims.length) {\n        return;\n    }\n    stream.keyword('TXAN');\n    stream.int32(byteLengthTextureAnims(model) - 8);\n    for (var _i = 0, _a = model.TextureAnims; _i < _a.length; _i++) {\n        var anim = _a[_i];\n        stream.int32(byteLengthTextureAnim(anim));\n        if (anim.Translation) {\n            stream.keyword('KTAT');\n            stream.animVector(anim.Translation, AnimVectorType.FLOAT3);\n        }\n        if (anim.Rotation) {\n            stream.keyword('KTAR');\n            stream.animVector(anim.Rotation, AnimVectorType.FLOAT4);\n        }\n        if (anim.Scaling) {\n            stream.keyword('KTAS');\n            stream.animVector(anim.Scaling, AnimVectorType.FLOAT3);\n        }\n    }\n}\nfunction byteLengthGeoset(model, geoset) {\n    var _a, _b;\n    return 4 /* size */ +\n        4 /* VRTX keyword */ +\n        4 /* vertices count */ +\n        4 * geoset.Vertices.length /* vertices data */ +\n        4 /* NRMS keyword */ +\n        4 /* normals count */ +\n        4 * geoset.Normals.length /* normals data */ +\n        4 /* PTYP keyword */ +\n        4 /* primitive count */ +\n        4 /* int \"4\" */ +\n        4 /* PCNT keyword */ +\n        4 /* face group count */ +\n        4 /* faces count */ +\n        4 /* PVTX keyword */ +\n        4 /* indices count */ +\n        2 * geoset.Faces.length /* indices data */ +\n        4 /* GNDX keyword */ +\n        4 /* vertex group count */ +\n        geoset.VertexGroup.length /* vertex group data */ +\n        4 /* MTGC keyword */ +\n        4 /* group count */ +\n        4 * geoset.Groups.length /* group data */ +\n        4 /* MATS keyword */ +\n        4 /* total group count */ +\n        4 * geoset.TotalGroupsCount /* groups data */ +\n        4 /* MaterialID */ +\n        4 /* SelectionGroup */ +\n        4 /* Unselectable */ +\n        (model.Version >= 900 ?\n            4 /* LevelOfDetail */ +\n                80 /* Name */ :\n            0) +\n        ((model.Version >= 900 && ((_a = geoset.Tangents) === null || _a === void 0 ? void 0 : _a.length)) ?\n            4 /* TANG keyword */ +\n                4 /* Tangents count */ +\n                4 * geoset.Tangents.length /* Tangents data */ :\n            0) +\n        ((model.Version >= 900 && ((_b = geoset.SkinWeights) === null || _b === void 0 ? void 0 : _b.length)) ?\n            4 /* SKIN keyword */ +\n                4 /* SkinWeights count */ +\n                geoset.SkinWeights.length /* SkinWeights data */ :\n            0) +\n        4 * 7 /* extent */ +\n        4 /* geoset anim count */ +\n        4 * 7 * geoset.Anims.length /* geoset anim data */ +\n        4 /* UVAS keyword */ +\n        4 /* TVertices count */ +\n        sum(geoset.TVertices.map(function (tvertices) {\n            return 4 /* UVBS keyword */ +\n                4 /* texture coord count */ +\n                4 * tvertices.length;\n        } /* texture coord data */));\n}\nfunction byteLengthGeosets(model) {\n    if (!model.Geosets.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Geosets.map(function (geoset) { return byteLengthGeoset(model, geoset); }));\n}\nfunction generateGeosets(model, stream) {\n    if (!model.Geosets.length) {\n        return;\n    }\n    stream.keyword('GEOS');\n    stream.int32(byteLengthGeosets(model) - 8);\n    for (var _i = 0, _a = model.Geosets; _i < _a.length; _i++) {\n        var geoset = _a[_i];\n        stream.int32(byteLengthGeoset(model, geoset));\n        stream.keyword('VRTX');\n        stream.int32(geoset.Vertices.length / 3);\n        stream.float32Array(geoset.Vertices);\n        stream.keyword('NRMS');\n        stream.int32(geoset.Normals.length / 3);\n        stream.float32Array(geoset.Normals);\n        stream.keyword('PTYP');\n        stream.int32(1);\n        stream.int32(4);\n        stream.keyword('PCNT');\n        stream.int32(1);\n        stream.int32(geoset.Faces.length);\n        stream.keyword('PVTX');\n        stream.int32(geoset.Faces.length);\n        stream.uint16Array(geoset.Faces);\n        stream.keyword('GNDX');\n        stream.int32(geoset.VertexGroup.length);\n        stream.uint8Array(geoset.VertexGroup);\n        stream.keyword('MTGC');\n        stream.int32(geoset.Groups.length);\n        for (var i = 0; i < geoset.Groups.length; ++i) {\n            stream.int32(geoset.Groups[i].length);\n        }\n        stream.keyword('MATS');\n        stream.int32(geoset.TotalGroupsCount);\n        for (var _b = 0, _c = geoset.Groups; _b < _c.length; _b++) {\n            var group = _c[_b];\n            for (var _d = 0, group_1 = group; _d < group_1.length; _d++) {\n                var index = group_1[_d];\n                stream.int32(index);\n            }\n        }\n        stream.int32(geoset.MaterialID);\n        stream.int32(geoset.SelectionGroup);\n        stream.int32(geoset.Unselectable ? 4 : 0);\n        if (model.Version >= 900) {\n            stream.int32(typeof geoset.LevelOfDetail === 'number' ? geoset.LevelOfDetail : -1);\n            stream.str(geoset.Name || '', 80);\n        }\n        generateExtent(geoset, stream);\n        stream.int32(geoset.Anims.length);\n        for (var _e = 0, _f = geoset.Anims; _e < _f.length; _e++) {\n            var anim = _f[_e];\n            generateExtent(anim, stream);\n        }\n        if (model.Version >= 900) {\n            if (geoset.Tangents && geoset.Tangents.length) {\n                stream.keyword('TANG');\n                stream.int32(geoset.Tangents.length / 4);\n                stream.float32Array(geoset.Tangents);\n            }\n            if (geoset.SkinWeights && geoset.SkinWeights.length) {\n                stream.keyword('SKIN');\n                stream.int32(geoset.SkinWeights.length);\n                stream.uint8Array(geoset.SkinWeights);\n            }\n        }\n        stream.keyword('UVAS');\n        stream.int32(geoset.TVertices.length);\n        for (var _g = 0, _h = geoset.TVertices; _g < _h.length; _g++) {\n            var tvertices = _h[_g];\n            stream.keyword('UVBS');\n            stream.int32(tvertices.length / 2);\n            stream.float32Array(tvertices);\n        }\n    }\n}\nfunction byteLengthGeosetAnim(anim) {\n    return 4 /* size */ +\n        4 /* static Alpha */ +\n        4 /* Flags */ +\n        4 * 3 /* static Color */ +\n        4 /* GeosetId */ +\n        (typeof anim.Alpha !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(anim.Alpha, AnimVectorType.FLOAT1) :\n            0) +\n        (anim.Color && !(anim.Color instanceof Float32Array) ?\n            4 /* keyword */ + byteLengthAnimVector(anim.Color, AnimVectorType.FLOAT3) :\n            0);\n}\nfunction byteLengthGeosetAnims(model) {\n    if (!model.GeosetAnims.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.GeosetAnims.map(function (anim) { return byteLengthGeosetAnim(anim); }));\n}\nfunction generateGeosetAnims(model, stream) {\n    if (!model.GeosetAnims.length) {\n        return;\n    }\n    stream.keyword('GEOA');\n    stream.int32(byteLengthGeosetAnims(model) - 8);\n    for (var _i = 0, _a = model.GeosetAnims; _i < _a.length; _i++) {\n        var anim = _a[_i];\n        stream.int32(byteLengthGeosetAnim(anim));\n        stream.float32(typeof anim.Alpha === 'number' ? anim.Alpha : 1);\n        stream.int32(anim.Flags);\n        if (anim.Color && anim.Color instanceof Float32Array) {\n            stream.float32(anim.Color[0]);\n            stream.float32(anim.Color[1]);\n            stream.float32(anim.Color[2]);\n        }\n        else {\n            stream.float32(1);\n            stream.float32(1);\n            stream.float32(1);\n        }\n        stream.int32(anim.GeosetId !== null ? anim.GeosetId : NONE);\n        if (anim.Alpha !== null && typeof anim.Alpha !== 'number') {\n            stream.keyword('KGAO');\n            stream.animVector(anim.Alpha, AnimVectorType.FLOAT1);\n        }\n        if (anim.Color && !(anim.Color instanceof Float32Array)) {\n            stream.keyword('KGAC');\n            stream.animVector(anim.Color, AnimVectorType.FLOAT3);\n        }\n    }\n}\nvar MODEL_NODE_NAME_LENGTH = 0x50;\nfunction byteLengthNode(node) {\n    return 4 /* size */ +\n        MODEL_NODE_NAME_LENGTH +\n        4 /* ObjectId */ +\n        4 /* Parent */ +\n        4 /* Flags */ +\n        (node.Translation ? 4 /*keyword */ + byteLengthAnimVector(node.Translation, AnimVectorType.FLOAT3) : 0) +\n        (node.Rotation ? 4 /*keyword */ + byteLengthAnimVector(node.Rotation, AnimVectorType.FLOAT4) : 0) +\n        (node.Scaling ? 4 /*keyword */ + byteLengthAnimVector(node.Scaling, AnimVectorType.FLOAT3) : 0);\n}\nfunction byteLengthBone(bone) {\n    return byteLengthNode(bone) +\n        4 /* GeosetId */ +\n        4; /* GeosetAnimId */\n}\nfunction byteLengthBones(model) {\n    if (!model.Bones.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Bones.map(byteLengthBone));\n}\nfunction generateNode(node, stream) {\n    stream.int32(byteLengthNode(node));\n    stream.str(node.Name, MODEL_NODE_NAME_LENGTH);\n    stream.int32(node.ObjectId !== null ? node.ObjectId : NONE);\n    stream.int32(node.Parent !== null ? node.Parent : NONE);\n    stream.int32(node.Flags);\n    if (node.Translation) {\n        stream.keyword('KGTR');\n        stream.animVector(node.Translation, AnimVectorType.FLOAT3);\n    }\n    if (node.Rotation) {\n        stream.keyword('KGRT');\n        stream.animVector(node.Rotation, AnimVectorType.FLOAT4);\n    }\n    if (node.Scaling) {\n        stream.keyword('KGSC');\n        stream.animVector(node.Scaling, AnimVectorType.FLOAT3);\n    }\n}\nfunction generateBones(model, stream) {\n    if (!model.Bones.length) {\n        return;\n    }\n    stream.keyword('BONE');\n    stream.int32(byteLengthBones(model) - 8);\n    for (var _i = 0, _a = model.Bones; _i < _a.length; _i++) {\n        var bone = _a[_i];\n        generateNode(bone, stream);\n        stream.int32(bone.GeosetId !== null ? bone.GeosetId : NONE);\n        stream.int32(bone.GeosetAnimId !== null ? bone.GeosetAnimId : NONE);\n    }\n}\nfunction byteLengthLight(light) {\n    return 4 /* size */ +\n        byteLengthNode(light) +\n        4 /* LightType */ +\n        4 /* AttenuationStart */ +\n        4 /* AttenuationEnd */ +\n        4 * 3 /* static Color */ +\n        4 /* static Intensity */ +\n        4 * 3 /* static AmbColor */ +\n        4 /* static AmbIntensity */ +\n        (light.Visibility ? 4 /* keyword */ + byteLengthAnimVector(light.Visibility, AnimVectorType.FLOAT1) : 0) +\n        (light.Color && !(light.Color instanceof Float32Array) ?\n            4 /* keyword */ + byteLengthAnimVector(light.Color, AnimVectorType.FLOAT3) :\n            0) +\n        (light.Intensity && typeof light.Intensity !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(light.Intensity, AnimVectorType.FLOAT1) :\n            0) +\n        (light.AttenuationStart && typeof light.AttenuationStart !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(light.AttenuationStart, AnimVectorType.FLOAT1) :\n            0) +\n        (light.AttenuationEnd && typeof light.AttenuationEnd !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(light.AttenuationEnd, AnimVectorType.FLOAT1) :\n            0) +\n        (light.AmbColor && !(light.AmbColor instanceof Float32Array) ?\n            4 /* keyword */ + byteLengthAnimVector(light.AmbColor, AnimVectorType.FLOAT3) :\n            0) +\n        (light.AmbIntensity && typeof light.AmbIntensity !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(light.AmbIntensity, AnimVectorType.FLOAT1) :\n            0);\n}\nfunction byteLengthLights(model) {\n    if (!model.Lights.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Lights.map(byteLengthLight));\n}\nfunction generateLights(model, stream) {\n    if (!model.Lights.length) {\n        return;\n    }\n    stream.keyword('LITE');\n    stream.int32(byteLengthLights(model) - 8);\n    for (var _i = 0, _a = model.Lights; _i < _a.length; _i++) {\n        var light = _a[_i];\n        stream.int32(byteLengthLight(light));\n        generateNode(light, stream);\n        stream.int32(light.LightType);\n        stream.float32(typeof light.AttenuationStart === 'number' ? light.AttenuationStart : 0);\n        stream.float32(typeof light.AttenuationEnd === 'number' ? light.AttenuationEnd : 0);\n        if (light.Color instanceof Float32Array) {\n            stream.float32(light.Color[0]);\n            stream.float32(light.Color[1]);\n            stream.float32(light.Color[2]);\n        }\n        else {\n            stream.float32(1);\n            stream.float32(1);\n            stream.float32(1);\n        }\n        stream.float32(typeof light.Intensity === 'number' ? light.Intensity : 0);\n        if (light.AmbColor instanceof Float32Array) {\n            stream.float32(light.AmbColor[0]);\n            stream.float32(light.AmbColor[1]);\n            stream.float32(light.AmbColor[2]);\n        }\n        else {\n            stream.float32(1);\n            stream.float32(1);\n            stream.float32(1);\n        }\n        stream.float32(typeof light.AmbIntensity === 'number' ? light.AmbIntensity : 0);\n        if (light.Intensity && typeof light.Intensity !== 'number') {\n            stream.keyword('KLAI');\n            stream.animVector(light.Intensity, AnimVectorType.FLOAT1);\n        }\n        if (light.Visibility) {\n            stream.keyword('KLAV');\n            stream.animVector(light.Visibility, AnimVectorType.FLOAT1);\n        }\n        if (light.Color && !(light.Color instanceof Float32Array)) {\n            stream.keyword('KLAC');\n            stream.animVector(light.Color, AnimVectorType.FLOAT3);\n        }\n        if (light.AmbColor && !(light.AmbColor instanceof Float32Array)) {\n            stream.keyword('KLBC');\n            stream.animVector(light.AmbColor, AnimVectorType.FLOAT3);\n        }\n        if (light.AmbIntensity && typeof light.AmbIntensity !== 'number') {\n            stream.keyword('KLBI');\n            stream.animVector(light.AmbIntensity, AnimVectorType.FLOAT1);\n        }\n        if (light.AttenuationStart && typeof light.AttenuationStart !== 'number') {\n            stream.keyword('KLAS');\n            stream.animVector(light.AttenuationStart, AnimVectorType.INT1);\n        }\n        if (light.AttenuationEnd && typeof light.AttenuationEnd !== 'number') {\n            stream.keyword('KLAE');\n            stream.animVector(light.AttenuationEnd, AnimVectorType.INT1);\n        }\n    }\n}\nfunction byteLengthHelpers(model) {\n    if (model.Helpers.length === 0) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Helpers.map(byteLengthNode));\n}\nfunction generateHelpers(model, stream) {\n    if (model.Helpers.length === 0) {\n        return;\n    }\n    stream.keyword('HELP');\n    stream.int32(byteLengthHelpers(model) - 8);\n    for (var _i = 0, _a = model.Helpers; _i < _a.length; _i++) {\n        var helper = _a[_i];\n        generateNode(helper, stream);\n    }\n}\nvar MODEL_ATTACHMENT_PATH_LENGTH = 0x100;\nfunction byteLengthAttachment(attachment) {\n    return 4 /* size */ +\n        byteLengthNode(attachment) +\n        MODEL_ATTACHMENT_PATH_LENGTH +\n        4 /* zero ? */ +\n        4 /* AttachmentID */ +\n        (attachment.Visibility ?\n            4 /* keyword */ + byteLengthAnimVector(attachment.Visibility, AnimVectorType.FLOAT1) :\n            0);\n}\nfunction byteLengthAttachments(model) {\n    if (model.Attachments.length === 0) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Attachments.map(byteLengthAttachment));\n}\nfunction generateAttachments(model, stream) {\n    if (model.Attachments.length === 0) {\n        return;\n    }\n    stream.keyword('ATCH');\n    stream.int32(byteLengthAttachments(model) - 8);\n    for (var _i = 0, _a = model.Attachments; _i < _a.length; _i++) {\n        var attachment = _a[_i];\n        stream.int32(byteLengthAttachment(attachment));\n        generateNode(attachment, stream);\n        stream.str(attachment.Path || '', MODEL_ATTACHMENT_PATH_LENGTH);\n        stream.int32(0);\n        stream.int32(attachment.AttachmentID);\n        if (attachment.Visibility) {\n            stream.keyword('KATV');\n            stream.animVector(attachment.Visibility, AnimVectorType.FLOAT1);\n        }\n    }\n}\nfunction byteLengthPivotPoints(model) {\n    if (!model.PivotPoints.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        4 * 3 * model.PivotPoints.length;\n}\nfunction generatePivotPoints(model, stream) {\n    if (!model.PivotPoints.length) {\n        return;\n    }\n    stream.keyword('PIVT');\n    stream.int32(model.PivotPoints.length * 4 * 3);\n    for (var _i = 0, _a = model.PivotPoints; _i < _a.length; _i++) {\n        var point = _a[_i];\n        stream.float32Array(point);\n    }\n}\nvar MODEL_PARTICLE_EMITTER_PATH_LENGTH = 0x100;\nfunction byteLengthParticleEmitter(emitter) {\n    return 4 /* size */ +\n        byteLengthNode(emitter) +\n        4 /* EmissionRate */ +\n        4 /* Gravity */ +\n        4 /* Longitude */ +\n        4 /* Latitude */ +\n        MODEL_PARTICLE_EMITTER_PATH_LENGTH +\n        4 +\n        4 /* LifeSpan */ +\n        4 /* InitVelocity */ +\n        (emitter.Visibility && typeof emitter.Visibility !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Visibility, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.EmissionRate && typeof emitter.EmissionRate !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.EmissionRate, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Gravity && typeof emitter.Gravity !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Gravity, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Longitude && typeof emitter.Longitude !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Longitude, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Latitude && typeof emitter.Latitude !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Latitude, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.LifeSpan && typeof emitter.LifeSpan !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.LifeSpan, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.InitVelocity && typeof emitter.InitVelocity !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.InitVelocity, AnimVectorType.FLOAT1) :\n            0);\n}\nfunction byteLengthParticleEmitters(model) {\n    if (!model.ParticleEmitters.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.ParticleEmitters.map(byteLengthParticleEmitter));\n}\nfunction generateParticleEmitters(model, stream) {\n    if (!model.ParticleEmitters.length) {\n        return;\n    }\n    stream.keyword('PREM');\n    stream.int32(byteLengthParticleEmitters(model) - 8);\n    for (var _i = 0, _a = model.ParticleEmitters; _i < _a.length; _i++) {\n        var emitter = _a[_i];\n        stream.int32(byteLengthParticleEmitter(emitter));\n        generateNode(emitter, stream);\n        stream.float32(typeof emitter.EmissionRate === 'number' ? emitter.EmissionRate : 0);\n        stream.float32(typeof emitter.Gravity === 'number' ? emitter.Gravity : 0);\n        stream.float32(typeof emitter.Longitude === 'number' ? emitter.Longitude : 0);\n        stream.float32(typeof emitter.Latitude === 'number' ? emitter.Latitude : 0);\n        stream.str(emitter.Path, MODEL_PARTICLE_EMITTER_PATH_LENGTH);\n        stream.int32(0);\n        stream.float32(typeof emitter.LifeSpan === 'number' ? emitter.LifeSpan : 0);\n        stream.float32(typeof emitter.InitVelocity === 'number' ? emitter.InitVelocity : 0);\n        if (emitter.Visibility && typeof emitter.Visibility !== 'number') {\n            stream.keyword('KPEV');\n            stream.animVector(emitter.Visibility, AnimVectorType.FLOAT1);\n        }\n        if (emitter.EmissionRate && typeof emitter.EmissionRate !== 'number') {\n            stream.keyword('KPEE');\n            stream.animVector(emitter.EmissionRate, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Gravity && typeof emitter.Gravity !== 'number') {\n            stream.keyword('KPEG');\n            stream.animVector(emitter.Gravity, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Longitude && typeof emitter.Longitude !== 'number') {\n            stream.keyword('KPLN');\n            stream.animVector(emitter.Longitude, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Latitude && typeof emitter.Latitude !== 'number') {\n            stream.keyword('KPLT');\n            stream.animVector(emitter.Latitude, AnimVectorType.FLOAT1);\n        }\n        if (emitter.LifeSpan && typeof emitter.LifeSpan !== 'number') {\n            stream.keyword('KPEL');\n            stream.animVector(emitter.LifeSpan, AnimVectorType.FLOAT1);\n        }\n        if (emitter.InitVelocity && typeof emitter.InitVelocity !== 'number') {\n            stream.keyword('KPES');\n            stream.animVector(emitter.InitVelocity, AnimVectorType.FLOAT1);\n        }\n    }\n}\nfunction byteLengthParticleEmitter2(emitter) {\n    return 4 /* size */ +\n        byteLengthNode(emitter) +\n        4 /* static Speed */ +\n        4 /* Variation */ +\n        4 /* static Latitude */ +\n        4 /* Gravity */ +\n        4 /* LifeSpan */ +\n        4 /* static EmissionRate */ +\n        4 /* static Length */ +\n        4 /* static Width */ +\n        4 /* FilterMode */ +\n        4 /* Rows */ +\n        4 /* Columns */ +\n        4 /* FrameFlags */ +\n        4 /* TailLength */ +\n        4 /* Time */ +\n        4 * 3 * 3 /* SegmentColor */ +\n        3 /* Alpha uint * 3 */ +\n        4 * 3 /* ParticleScaling */ +\n        4 * 3 /* LifeSpanUVAnim */ +\n        4 * 3 /* DecayUVAnim */ +\n        4 * 3 /* TailUVAnim */ +\n        4 * 3 /* TailDecayUVAnim */ +\n        4 /* TextureID */ +\n        4 /* Squirt */ +\n        4 /* PriorityPlane */ +\n        4 /* ReplaceableId */ +\n        (emitter.Visibility && typeof emitter.Visibility !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Visibility, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.EmissionRate && typeof emitter.EmissionRate !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.EmissionRate, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Width && typeof emitter.Width !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Width, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Length && typeof emitter.Length !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Length, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Speed && typeof emitter.Speed !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Speed, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Latitude && typeof emitter.Latitude !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Latitude, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Gravity && typeof emitter.Gravity !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Gravity, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Variation && typeof emitter.Variation !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Variation, AnimVectorType.FLOAT1) :\n            0);\n}\nfunction byteLengthParticleEmitters2(model) {\n    if (!model.ParticleEmitters2.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.ParticleEmitters2.map(byteLengthParticleEmitter2));\n}\nfunction generateParticleEmitters2(model, stream) {\n    if (!model.ParticleEmitters2.length) {\n        return;\n    }\n    stream.keyword('PRE2');\n    stream.int32(byteLengthParticleEmitters2(model) - 8);\n    for (var _i = 0, _a = model.ParticleEmitters2; _i < _a.length; _i++) {\n        var emitter = _a[_i];\n        stream.int32(byteLengthParticleEmitter2(emitter));\n        generateNode(emitter, stream);\n        stream.float32(typeof emitter.Speed === 'number' ? emitter.Speed : 0);\n        stream.float32(typeof emitter.Variation === 'number' ? emitter.Variation : 0);\n        stream.float32(typeof emitter.Latitude === 'number' ? emitter.Latitude : 0);\n        stream.float32(typeof emitter.Gravity === 'number' ? emitter.Gravity : 0);\n        stream.float32(emitter.LifeSpan);\n        stream.float32(typeof emitter.EmissionRate === 'number' ? emitter.EmissionRate : 0);\n        stream.float32(typeof emitter.Width === 'number' ? emitter.Width : 0);\n        stream.float32(typeof emitter.Length === 'number' ? emitter.Length : 0);\n        stream.int32(emitter.FilterMode);\n        stream.int32(emitter.Rows);\n        stream.int32(emitter.Columns);\n        if (emitter.FrameFlags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Head &&\n            emitter.FrameFlags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Tail) {\n            stream.int32(2);\n        }\n        else if (emitter.FrameFlags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Tail) {\n            stream.int32(1);\n        }\n        else if (emitter.FrameFlags & _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Head) {\n            stream.int32(0);\n        }\n        stream.float32(emitter.TailLength);\n        stream.float32(emitter.Time);\n        for (var i = 0; i < 3; ++i) {\n            for (var j = 0; j < 3; ++j) {\n                stream.float32(emitter.SegmentColor[i][j]);\n            }\n        }\n        for (var i = 0; i < 3; ++i) {\n            stream.uint8(emitter.Alpha[i]);\n        }\n        for (var i = 0; i < 3; ++i) {\n            stream.float32(emitter.ParticleScaling[i]);\n        }\n        for (var _b = 0, _c = ['LifeSpanUVAnim', 'DecayUVAnim', 'TailUVAnim', 'TailDecayUVAnim']; _b < _c.length; _b++) {\n            var part = _c[_b];\n            for (var i = 0; i < 3; ++i) {\n                stream.int32(emitter[part][i]);\n            }\n        }\n        stream.int32(emitter.TextureID !== null ? emitter.TextureID : NONE);\n        stream.int32(emitter.Squirt ? 1 : 0);\n        stream.int32(emitter.PriorityPlane);\n        stream.int32(emitter.ReplaceableId);\n        if (emitter.Speed && typeof emitter.Speed !== 'number') {\n            stream.keyword('KP2S');\n            stream.animVector(emitter.Speed, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Latitude && typeof emitter.Latitude !== 'number') {\n            stream.keyword('KP2L');\n            stream.animVector(emitter.Latitude, AnimVectorType.FLOAT1);\n        }\n        if (emitter.EmissionRate && typeof emitter.EmissionRate !== 'number') {\n            stream.keyword('KP2E');\n            stream.animVector(emitter.EmissionRate, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Visibility && typeof emitter.Visibility !== 'number') {\n            stream.keyword('KP2V');\n            stream.animVector(emitter.Visibility, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Length && typeof emitter.Length !== 'number') {\n            stream.keyword('KP2N');\n            stream.animVector(emitter.Length, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Width && typeof emitter.Width !== 'number') {\n            stream.keyword('KP2W');\n            stream.animVector(emitter.Width, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Gravity && typeof emitter.Gravity !== 'number') {\n            stream.keyword('KP2G');\n            stream.animVector(emitter.Gravity, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Variation && typeof emitter.Variation !== 'number') {\n            stream.keyword('KP2R');\n            stream.animVector(emitter.Variation, AnimVectorType.FLOAT1);\n        }\n    }\n}\nfunction byteLengthRibbonEmitter(emitter) {\n    return 4 /* size */ +\n        byteLengthNode(emitter) +\n        4 /* static HeightAbove */ +\n        4 /* static HeightBelow */ +\n        4 /* Alpha */ +\n        4 * 3 /* Color */ +\n        4 /* LifeSpan */ +\n        4 /* TextureSlot */ +\n        4 /* EmissionRate */ +\n        4 /* Rows */ +\n        4 /* Columns */ +\n        4 /* MaterialID */ +\n        4 /* Gravity */ +\n        (emitter.Visibility ? 4 /* keyword */ + byteLengthAnimVector(emitter.Visibility, AnimVectorType.FLOAT1) : 0) +\n        (typeof emitter.HeightAbove !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.HeightAbove, AnimVectorType.FLOAT1) :\n            0) +\n        (typeof emitter.HeightBelow !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.HeightBelow, AnimVectorType.FLOAT1) :\n            0) +\n        (typeof emitter.Alpha !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Alpha, AnimVectorType.FLOAT1) :\n            0) +\n        (typeof emitter.TextureSlot !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.TextureSlot, AnimVectorType.FLOAT1) :\n            0);\n}\nfunction byteLengthRibbonEmitters(model) {\n    if (!model.RibbonEmitters.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.RibbonEmitters.map(byteLengthRibbonEmitter));\n}\nfunction generateRibbonEmitters(model, stream) {\n    if (!model.RibbonEmitters.length) {\n        return;\n    }\n    stream.keyword('RIBB');\n    stream.int32(byteLengthRibbonEmitters(model) - 8);\n    for (var _i = 0, _a = model.RibbonEmitters; _i < _a.length; _i++) {\n        var emitter = _a[_i];\n        stream.int32(byteLengthRibbonEmitter(emitter));\n        generateNode(emitter, stream);\n        stream.float32(typeof emitter.HeightAbove === 'number' ? emitter.HeightAbove : 0);\n        stream.float32(typeof emitter.HeightBelow === 'number' ? emitter.HeightBelow : 0);\n        stream.float32(typeof emitter.Alpha === 'number' ? emitter.Alpha : 0);\n        if (emitter.Color) {\n            stream.float32Array(emitter.Color);\n        }\n        else {\n            stream.float32(1);\n            stream.float32(1);\n            stream.float32(1);\n        }\n        stream.float32(emitter.LifeSpan);\n        stream.int32(typeof emitter.TextureSlot === 'number' ? emitter.TextureSlot : 0);\n        stream.int32(emitter.EmissionRate);\n        stream.int32(emitter.Rows);\n        stream.int32(emitter.Columns);\n        stream.int32(emitter.MaterialID);\n        stream.float32(emitter.Gravity);\n        if (emitter.Visibility) {\n            stream.keyword('KRVS');\n            stream.animVector(emitter.Visibility, AnimVectorType.FLOAT1);\n        }\n        if (typeof emitter.HeightAbove !== 'number') {\n            stream.keyword('KRHA');\n            stream.animVector(emitter.HeightAbove, AnimVectorType.FLOAT1);\n        }\n        if (typeof emitter.HeightBelow !== 'number') {\n            stream.keyword('KRHB');\n            stream.animVector(emitter.HeightBelow, AnimVectorType.FLOAT1);\n        }\n        if (typeof emitter.Alpha !== 'number') {\n            stream.keyword('KRAL');\n            stream.animVector(emitter.Alpha, AnimVectorType.FLOAT1);\n        }\n        if (typeof emitter.TextureSlot !== 'number') {\n            stream.keyword('KRTX');\n            stream.animVector(emitter.TextureSlot, AnimVectorType.INT1);\n        }\n    }\n}\nvar MODEL_CAMERA_NAME_LENGTH = 0x50;\nfunction byteLengthCamera(camera) {\n    return 4 /* size */ +\n        MODEL_CAMERA_NAME_LENGTH +\n        4 * 3 /* Position */ +\n        4 /* FieldOfView */ +\n        4 /* FarClip */ +\n        4 /* NearClip */ +\n        4 * 3 /* TargetPosition */ +\n        (camera.Translation ? 4 /* keyword */ + byteLengthAnimVector(camera.Translation, AnimVectorType.FLOAT3) : 0) +\n        (camera.TargetTranslation ?\n            4 /* keyword */ + byteLengthAnimVector(camera.TargetTranslation, AnimVectorType.FLOAT3) :\n            0) +\n        (camera.Rotation ? 4 /* keyword */ + byteLengthAnimVector(camera.Rotation, AnimVectorType.FLOAT1) : 0);\n}\nfunction byteLengthCameras(model) {\n    if (!model.Cameras.length) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.Cameras.map(byteLengthCamera));\n}\nfunction generateCameras(model, stream) {\n    if (!model.Cameras.length) {\n        return;\n    }\n    stream.keyword('CAMS');\n    stream.int32(byteLengthCameras(model) - 8);\n    for (var _i = 0, _a = model.Cameras; _i < _a.length; _i++) {\n        var camera = _a[_i];\n        stream.int32(byteLengthCamera(camera));\n        stream.str(camera.Name, MODEL_CAMERA_NAME_LENGTH);\n        stream.float32Array(camera.Position);\n        stream.float32(camera.FieldOfView);\n        stream.float32(camera.FarClip);\n        stream.float32(camera.NearClip);\n        stream.float32Array(camera.TargetPosition);\n        if (camera.Translation) {\n            stream.keyword('KCTR');\n            stream.animVector(camera.Translation, AnimVectorType.FLOAT3);\n        }\n        if (camera.Rotation) {\n            stream.keyword('KCRL');\n            stream.animVector(camera.Rotation, AnimVectorType.FLOAT1);\n        }\n        if (camera.TargetTranslation) {\n            stream.keyword('KTTR');\n            stream.animVector(camera.TargetTranslation, AnimVectorType.FLOAT3);\n        }\n    }\n}\nfunction byteLengthEventObject(eventObject) {\n    return byteLengthNode(eventObject) +\n        4 /* KEVT keyword */ +\n        4 /* count */ +\n        4 +\n        4 * eventObject.EventTrack.length;\n}\nfunction byteLengthEventObjects(model) {\n    if (model.EventObjects.length === 0) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.EventObjects.map(byteLengthEventObject));\n}\nfunction generateEventObjects(model, stream) {\n    if (model.EventObjects.length === 0) {\n        return;\n    }\n    stream.keyword('EVTS');\n    stream.int32(byteLengthEventObjects(model) - 8);\n    for (var _i = 0, _a = model.EventObjects; _i < _a.length; _i++) {\n        var eventObject = _a[_i];\n        generateNode(eventObject, stream);\n        stream.keyword('KEVT');\n        stream.int32(eventObject.EventTrack.length);\n        // todo GlobalSequenceId\n        stream.int32(NONE); // GlobalSequenceId ?\n        stream.uint32Array(eventObject.EventTrack);\n    }\n}\nfunction byteLengthCollisionShape(collisionShape) {\n    return byteLengthNode(collisionShape) +\n        4 /* Shape */ +\n        (collisionShape.Shape === _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Box ? 6 : 3) * 4 /* Vertices */ +\n        (collisionShape.Shape === _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Sphere ? 4 : 0); /* BoundsRadius */\n}\nfunction byteLengthCollisionShapes(model) {\n    if (model.CollisionShapes.length === 0) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.CollisionShapes.map(byteLengthCollisionShape));\n}\nfunction generateCollisionShapes(model, stream) {\n    if (model.CollisionShapes.length === 0) {\n        return;\n    }\n    stream.keyword('CLID');\n    stream.int32(byteLengthCollisionShapes(model) - 8);\n    for (var _i = 0, _a = model.CollisionShapes; _i < _a.length; _i++) {\n        var collisionShape = _a[_i];\n        generateNode(collisionShape, stream);\n        stream.int32(collisionShape.Shape);\n        stream.float32Array(collisionShape.Vertices);\n        if (collisionShape.Shape === _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Sphere) {\n            stream.float32(collisionShape.BoundsRadius);\n        }\n    }\n}\nfunction byteLengthFaceFX(model) {\n    if (model.Version < 900 || !model.FaceFX) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        (80 /* Name */ +\n            260 /* Path */) * model.FaceFX.length;\n}\nfunction generateFaceFX(model, stream) {\n    if (model.Version < 900 || !model.FaceFX) {\n        return;\n    }\n    stream.keyword('FAFX');\n    stream.int32(byteLengthFaceFX(model) - 8);\n    for (var _i = 0, _a = model.FaceFX; _i < _a.length; _i++) {\n        var faceFx = _a[_i];\n        stream.str(faceFx.Name, 80);\n        stream.str(faceFx.Path, 260);\n    }\n}\nfunction byteLengthBindPoseObject(bindPose) {\n    return 4 * 12 /* Matrices */ * bindPose.Matrices.length;\n}\nfunction byteLengthBindPoses(model) {\n    if (model.Version < 900 || !model.BindPoses) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        4 /* count */ +\n        sum(model.BindPoses.map(byteLengthBindPoseObject));\n}\nfunction generateBindPoses(model, stream) {\n    var _a;\n    if (model.Version < 900 || !((_a = model.BindPoses) === null || _a === void 0 ? void 0 : _a.length)) {\n        return;\n    }\n    stream.keyword('BPOS');\n    stream.int32(byteLengthBindPoses(model) - 8);\n    var totalCount = model.BindPoses.reduce(function (acc, bindPose) {\n        return acc + bindPose.Matrices.length;\n    }, 0);\n    stream.int32(totalCount);\n    for (var _i = 0, _b = model.BindPoses; _i < _b.length; _i++) {\n        var bindPose = _b[_i];\n        for (var _c = 0, _d = bindPose.Matrices; _c < _d.length; _c++) {\n            var matrix = _d[_c];\n            stream.float32Array(matrix);\n        }\n    }\n}\nfunction byteLengthParticleEmitterPopcorn(emitter) {\n    return 4 /* size */ +\n        byteLengthNode(emitter) +\n        4 /* static LifeSpan */ +\n        4 /* static EmissionRate */ +\n        4 /* static Speed */ +\n        4 * 3 /* static Color */ +\n        4 /* static Alpha */ +\n        4 /* ReplaceableId */ +\n        260 /* Path */ +\n        260 /* AnimVisibilityGuide */ +\n        (emitter.Alpha && typeof emitter.Alpha !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Alpha, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Visibility && typeof emitter.Visibility !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Visibility, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.EmissionRate && typeof emitter.EmissionRate !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.EmissionRate, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Color && !(emitter.Color instanceof Float32Array) ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Color, AnimVectorType.FLOAT3) :\n            0) +\n        (emitter.LifeSpan && typeof emitter.LifeSpan !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.LifeSpan, AnimVectorType.FLOAT1) :\n            0) +\n        (emitter.Speed && typeof emitter.Speed !== 'number' ?\n            4 /* keyword */ + byteLengthAnimVector(emitter.Speed, AnimVectorType.FLOAT1) :\n            0);\n}\nfunction byteLengthParticleEmitterPopcorns(model) {\n    var _a;\n    if (model.Version < 900 || !((_a = model.ParticleEmitterPopcorns) === null || _a === void 0 ? void 0 : _a.length)) {\n        return 0;\n    }\n    return 4 /* keyword */ +\n        4 /* size */ +\n        sum(model.ParticleEmitterPopcorns.map(byteLengthParticleEmitterPopcorn));\n}\nfunction generateParticleEmitterPopcorns(model, stream) {\n    var _a;\n    if (model.Version < 900 || !((_a = model.ParticleEmitterPopcorns) === null || _a === void 0 ? void 0 : _a.length)) {\n        return;\n    }\n    stream.keyword('CORN');\n    stream.int32(byteLengthParticleEmitterPopcorns(model) - 8);\n    for (var _i = 0, _b = model.ParticleEmitterPopcorns; _i < _b.length; _i++) {\n        var emitter = _b[_i];\n        stream.int32(byteLengthParticleEmitterPopcorn(emitter));\n        generateNode(emitter, stream);\n        stream.float32(typeof emitter.LifeSpan === 'number' ? emitter.LifeSpan : 0);\n        stream.float32(typeof emitter.EmissionRate === 'number' ? emitter.EmissionRate : 1);\n        stream.float32(typeof emitter.Speed === 'number' ? emitter.Speed : 0);\n        if (emitter.Color instanceof Float32Array) {\n            stream.float32(emitter.Color[0]);\n            stream.float32(emitter.Color[1]);\n            stream.float32(emitter.Color[2]);\n        }\n        else {\n            stream.float32(1);\n            stream.float32(1);\n            stream.float32(1);\n        }\n        stream.float32(typeof emitter.Alpha === 'number' ? emitter.Alpha : 1);\n        stream.int32(typeof emitter.ReplaceableId === 'number' ? emitter.ReplaceableId : 0);\n        stream.str(emitter.Path, 260);\n        stream.str(emitter.AnimVisibilityGuide, 260);\n        if (emitter.Alpha && typeof emitter.Alpha !== 'number') {\n            stream.keyword('KPPA');\n            stream.animVector(emitter.Alpha, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Color && !(emitter.Color instanceof Float32Array)) {\n            stream.keyword('KPPC');\n            stream.animVector(emitter.Color, AnimVectorType.FLOAT3);\n        }\n        if (emitter.EmissionRate && typeof emitter.EmissionRate !== 'number') {\n            stream.keyword('KPPE');\n            stream.animVector(emitter.EmissionRate, AnimVectorType.FLOAT1);\n        }\n        if (emitter.LifeSpan && typeof emitter.LifeSpan !== 'number') {\n            stream.keyword('KPPL');\n            stream.animVector(emitter.LifeSpan, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Speed && typeof emitter.Speed !== 'number') {\n            stream.keyword('KPPS');\n            stream.animVector(emitter.Speed, AnimVectorType.FLOAT1);\n        }\n        if (emitter.Visibility && typeof emitter.Visibility !== 'number') {\n            stream.keyword('KPPV');\n            stream.animVector(emitter.Visibility, AnimVectorType.FLOAT1);\n        }\n    }\n}\nvar byteLength = [\n    byteLengthVersion,\n    byteLengthModelInfo,\n    byteLengthSequences,\n    byteLengthGlobalSequences,\n    byteLengthMaterials,\n    byteLengthTextures,\n    byteLengthTextureAnims,\n    byteLengthGeosets,\n    byteLengthGeosetAnims,\n    byteLengthBones,\n    byteLengthLights,\n    byteLengthHelpers,\n    byteLengthAttachments,\n    byteLengthPivotPoints,\n    byteLengthParticleEmitters,\n    byteLengthParticleEmitters2,\n    byteLengthParticleEmitterPopcorns,\n    byteLengthRibbonEmitters,\n    byteLengthCameras,\n    byteLengthEventObjects,\n    byteLengthCollisionShapes,\n    byteLengthFaceFX,\n    byteLengthBindPoses\n];\nvar generators = [\n    generateVersion,\n    generateModelInfo,\n    generateSequences,\n    generateGlobalSequences,\n    generateMaterials,\n    generateTextures,\n    generateTextureAnims,\n    generateGeosets,\n    generateGeosetAnims,\n    generateBones,\n    generateLights,\n    generateHelpers,\n    generateAttachments,\n    generatePivotPoints,\n    generateParticleEmitters,\n    generateParticleEmitters2,\n    generateParticleEmitterPopcorns,\n    generateRibbonEmitters,\n    generateCameras,\n    generateEventObjects,\n    generateCollisionShapes,\n    generateFaceFX,\n    generateBindPoses\n];\nfunction generate(model) {\n    var totalLength = 4 /* format keyword */;\n    for (var _i = 0, byteLength_1 = byteLength; _i < byteLength_1.length; _i++) {\n        var lenFunc = byteLength_1[_i];\n        totalLength += lenFunc(model);\n    }\n    var res = new ArrayBuffer(totalLength);\n    var stream = new Stream(res);\n    stream.keyword('MDLX');\n    for (var _a = 0, generators_1 = generators; _a < generators_1.length; _a++) {\n        var generator = generators_1[_a];\n        generator(model, stream);\n    }\n    return res;\n}\n\n\n//# sourceURL=webpack://war3-model/./mdx/generate.ts?");

/***/ }),

/***/ "./mdx/parse.ts":
/*!**********************!*\
  !*** ./mdx/parse.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model */ \"./model.ts\");\n/* harmony import */ var _renderer_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/util */ \"./renderer/util.ts\");\nvar _a;\n\n\nvar BIG_ENDIAN = true;\nvar NONE = -1;\nvar AnimVectorType;\n(function (AnimVectorType) {\n    AnimVectorType[AnimVectorType[\"INT1\"] = 0] = \"INT1\";\n    AnimVectorType[AnimVectorType[\"FLOAT1\"] = 1] = \"FLOAT1\";\n    AnimVectorType[AnimVectorType[\"FLOAT3\"] = 2] = \"FLOAT3\";\n    AnimVectorType[AnimVectorType[\"FLOAT4\"] = 3] = \"FLOAT4\";\n})(AnimVectorType || (AnimVectorType = {}));\nvar animVectorSize = (_a = {},\n    _a[AnimVectorType.INT1] = 1,\n    _a[AnimVectorType.FLOAT1] = 1,\n    _a[AnimVectorType.FLOAT3] = 3,\n    _a[AnimVectorType.FLOAT4] = 4,\n    _a);\nvar State = /** @class */ (function () {\n    function State(arrayBuffer) {\n        this.ab = arrayBuffer;\n        this.pos = 0;\n        this.length = arrayBuffer.byteLength;\n        this.view = new DataView(this.ab);\n        this.uint = new Uint8Array(this.ab);\n    }\n    State.prototype.keyword = function () {\n        var res = String.fromCharCode(this.uint[this.pos], this.uint[this.pos + 1], this.uint[this.pos + 2], this.uint[this.pos + 3]);\n        this.pos += 4;\n        return res;\n    };\n    State.prototype.expectKeyword = function (keyword, errorText) {\n        var curKeyword = this.keyword();\n        if (curKeyword !== keyword) {\n            throw new Error(errorText);\n        }\n    };\n    State.prototype.uint8 = function () {\n        return this.view.getUint8(this.pos++);\n    };\n    State.prototype.uint16 = function () {\n        var res = this.view.getUint16(this.pos, BIG_ENDIAN);\n        this.pos += 2;\n        return res;\n    };\n    State.prototype.int32 = function () {\n        var res = this.view.getInt32(this.pos, BIG_ENDIAN);\n        this.pos += 4;\n        return res;\n    };\n    State.prototype.float32 = function () {\n        var res = this.view.getFloat32(this.pos, BIG_ENDIAN);\n        this.pos += 4;\n        return res;\n    };\n    State.prototype.float32Array = function (len) {\n        var res = new Float32Array(len);\n        for (var i = 0; i < len; ++i) {\n            res[i] = this.float32();\n        }\n        return res;\n    };\n    State.prototype.uint8Array = function (len) {\n        var res = new Uint8Array(len);\n        for (var i = 0; i < len; ++i) {\n            res[i] = this.uint8();\n        }\n        return res;\n    };\n    State.prototype.str = function (length) {\n        // actual string length\n        // data may consist of ['a', 'b', 'c', 0, 0, 0]\n        var stringLength = length;\n        while (this.uint[this.pos + stringLength - 1] === 0 && stringLength > 0) {\n            --stringLength;\n        }\n        // ??\n        // TS2461:Type 'Uint8Array' is not an array type.\n        // let res = String.fromCharCode(...this.uint.slice(this.pos, this.pos + length));\n        // eslint-disable-next-line prefer-spread\n        var res = String.fromCharCode.apply(String, this.uint.slice(this.pos, this.pos + stringLength));\n        this.pos += length;\n        return res;\n    };\n    State.prototype.animVector = function (type) {\n        var res = {\n            Keys: []\n        };\n        var isInt = type === AnimVectorType.INT1;\n        var vectorSize = animVectorSize[type];\n        var keysCount = this.int32();\n        res.LineType = this.int32();\n        res.GlobalSeqId = this.int32();\n        if (res.GlobalSeqId === NONE) {\n            res.GlobalSeqId = null;\n        }\n        for (var i = 0; i < keysCount; ++i) {\n            var animKeyFrame = {};\n            animKeyFrame.Frame = this.int32();\n            if (isInt) {\n                animKeyFrame.Vector = new Int32Array(vectorSize);\n            }\n            else {\n                animKeyFrame.Vector = new Float32Array(vectorSize);\n            }\n            for (var j = 0; j < vectorSize; ++j) {\n                if (isInt) {\n                    animKeyFrame.Vector[j] = this.int32();\n                }\n                else {\n                    animKeyFrame.Vector[j] = this.float32();\n                }\n            }\n            if (res.LineType === _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Hermite || res.LineType === _model__WEBPACK_IMPORTED_MODULE_0__.LineType.Bezier) {\n                for (var _i = 0, _a = ['InTan', 'OutTan']; _i < _a.length; _i++) {\n                    var part = _a[_i];\n                    animKeyFrame[part] = new Float32Array(vectorSize);\n                    for (var j = 0; j < vectorSize; ++j) {\n                        if (isInt) {\n                            animKeyFrame[part][j] = this.int32();\n                        }\n                        else {\n                            animKeyFrame[part][j] = this.float32();\n                        }\n                    }\n                }\n            }\n            res.Keys.push(animKeyFrame);\n        }\n        return res;\n    };\n    return State;\n}());\nfunction parseExtent(obj, state) {\n    obj.BoundsRadius = state.float32();\n    for (var _i = 0, _a = ['MinimumExtent', 'MaximumExtent']; _i < _a.length; _i++) {\n        var key = _a[_i];\n        obj[key] = new Float32Array(3);\n        for (var i = 0; i < 3; ++i) {\n            obj[key][i] = state.float32();\n        }\n    }\n}\nfunction parseVersion(model, state) {\n    model.Version = state.int32();\n}\nvar MODEL_NAME_LENGTH = 0x150;\nfunction parseModelInfo(model, state) {\n    model.Info.Name = state.str(MODEL_NAME_LENGTH);\n    state.int32(); // unknown 4-byte sequence\n    parseExtent(model.Info, state);\n    model.Info.BlendTime = state.int32();\n}\nvar MODEL_SEQUENCE_NAME_LENGTH = 0x50;\nfunction parseSequences(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var name = state.str(MODEL_SEQUENCE_NAME_LENGTH);\n        var sequence = {};\n        sequence.Name = name;\n        var interval = new Uint32Array(2);\n        interval[0] = state.int32();\n        interval[1] = state.int32();\n        sequence.Interval = interval;\n        sequence.MoveSpeed = state.float32();\n        sequence.NonLooping = state.int32() > 0;\n        sequence.Rarity = state.float32();\n        state.int32(); // unknown 4-byte sequence (syncPoint?)\n        parseExtent(sequence, state);\n        model.Sequences.push(sequence);\n    }\n}\nfunction parseMaterials(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        state.int32(); // material size inclusive\n        var material = {\n            Layers: []\n        };\n        material.PriorityPlane = state.int32();\n        material.RenderMode = state.int32();\n        if (model.Version >= 900 && model.Version < 1100) {\n            material.Shader = state.str(80);\n        }\n        state.expectKeyword('LAYS', 'Incorrect materials format');\n        var layersCount = state.int32();\n        for (var i = 0; i < layersCount; ++i) {\n            var startPos2 = state.pos;\n            var size2 = state.int32();\n            var layer = {};\n            layer.FilterMode = state.int32();\n            layer.Shading = state.int32();\n            layer.TextureID = state.int32();\n            layer.TVertexAnimId = state.int32();\n            if (layer.TVertexAnimId === NONE) {\n                layer.TVertexAnimId = null;\n            }\n            layer.CoordId = state.int32();\n            layer.Alpha = state.float32();\n            if (model.Version >= 900) {\n                layer.EmissiveGain = state.float32();\n                if (model.Version >= 1000) {\n                    layer.FresnelColor = state.float32Array(3);\n                    layer.FresnelOpacity = state.float32();\n                    layer.FresnelTeamColor = state.float32();\n                }\n            }\n            if (model.Version >= 1100) {\n                layer.ShaderTypeId = state.int32(); // hd flag\n                var textureCount = state.int32();\n                for (var j = 0; j < textureCount; ++j) {\n                    var textureId = state.int32(); //layer_texture.id\n                    // const textureType = state.int32();\n                    state.int32();\n                    var textureType = j;\n                    var keyword = state.keyword();\n                    if (keyword === 'KMTF') {\n                        layer[_renderer_util__WEBPACK_IMPORTED_MODULE_1__.LAYER_TEXTURE_ID_MAP[textureType]] = state.animVector(AnimVectorType.INT1);\n                    }\n                    else {\n                        layer[_renderer_util__WEBPACK_IMPORTED_MODULE_1__.LAYER_TEXTURE_ID_MAP[textureType]] = textureId;\n                        state.pos -= 4;\n                    }\n                }\n            }\n            while (state.pos < startPos2 + size2) {\n                var keyword = state.keyword();\n                if (keyword === 'KMTA') {\n                    layer.Alpha = state.animVector(AnimVectorType.FLOAT1);\n                }\n                else if (keyword === 'KMTF') {\n                    layer.TextureID = state.animVector(AnimVectorType.INT1);\n                }\n                else if (keyword === 'KMTE' && model.Version >= 900) {\n                    layer.EmissiveGain = state.animVector(AnimVectorType.FLOAT1);\n                }\n                else if (keyword === 'KFC3' && model.Version >= 1000) {\n                    layer.FresnelColor = state.animVector(AnimVectorType.FLOAT3);\n                }\n                else if (keyword === 'KFCA' && model.Version >= 1000) {\n                    layer.FresnelOpacity = state.animVector(AnimVectorType.FLOAT1);\n                }\n                else if (keyword === 'KFTC' && model.Version >= 1000) {\n                    layer.FresnelTeamColor = state.animVector(AnimVectorType.FLOAT1);\n                }\n                else {\n                    throw new Error('Unknown layer chunk data ' + keyword);\n                }\n            }\n            material.Layers.push(layer);\n        }\n        model.Materials.push(material);\n    }\n}\nvar MODEL_TEXTURE_PATH_LENGTH = 0x100;\nfunction parseTextures(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var texture = {};\n        texture.ReplaceableId = state.int32();\n        texture.Image = state.str(MODEL_TEXTURE_PATH_LENGTH);\n        state.int32(); // unknown 4-byte sequence\n        texture.Flags = state.int32();\n        model.Textures.push(texture);\n    }\n}\nfunction parseGeosets(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var geoset = {};\n        state.int32(); // geoset size, not used\n        state.expectKeyword('VRTX', 'Incorrect geosets format');\n        var verticesCount = state.int32();\n        geoset.Vertices = new Float32Array(verticesCount * 3);\n        for (var i = 0; i < verticesCount * 3; ++i) {\n            geoset.Vertices[i] = state.float32();\n        }\n        state.expectKeyword('NRMS', 'Incorrect geosets format');\n        var normalsCount = state.int32();\n        geoset.Normals = new Float32Array(normalsCount * 3);\n        for (var i = 0; i < normalsCount * 3; ++i) {\n            geoset.Normals[i] = state.float32();\n        }\n        state.expectKeyword('PTYP', 'Incorrect geosets format');\n        var primitiveCount = state.int32();\n        for (var i = 0; i < primitiveCount; ++i) {\n            if (state.int32() !== 4) {\n                throw new Error('Incorrect geosets format');\n            }\n        }\n        state.expectKeyword('PCNT', 'Incorrect geosets format');\n        var faceGroupCount = state.int32();\n        for (var i = 0; i < faceGroupCount; ++i) {\n            state.int32();\n        }\n        state.expectKeyword('PVTX', 'Incorrect geosets format');\n        var indicesCount = state.int32();\n        geoset.Faces = new Uint16Array(indicesCount);\n        for (var i = 0; i < indicesCount; ++i) {\n            geoset.Faces[i] = state.uint16();\n        }\n        state.expectKeyword('GNDX', 'Incorrect geosets format');\n        var verticesGroupCount = state.int32();\n        geoset.VertexGroup = new Uint8Array(verticesGroupCount);\n        for (var i = 0; i < verticesGroupCount; ++i) {\n            geoset.VertexGroup[i] = state.uint8();\n        }\n        state.expectKeyword('MTGC', 'Incorrect geosets format');\n        var groupsCount = state.int32();\n        geoset.Groups = [];\n        for (var i = 0; i < groupsCount; ++i) {\n            // new Array(array length)\n            geoset.Groups[i] = new Array(state.int32());\n        }\n        state.expectKeyword('MATS', 'Incorrect geosets format');\n        geoset.TotalGroupsCount = state.int32();\n        var groupIndex = 0;\n        var groupCounter = 0;\n        for (var i = 0; i < geoset.TotalGroupsCount; ++i) {\n            if (groupIndex >= geoset.Groups[groupCounter].length) {\n                groupIndex = 0;\n                groupCounter++;\n            }\n            geoset.Groups[groupCounter][groupIndex++] = state.int32();\n        }\n        geoset.MaterialID = state.int32();\n        geoset.SelectionGroup = state.int32();\n        geoset.Unselectable = state.int32() > 0;\n        if (model.Version >= 900) {\n            geoset.LevelOfDetail = state.int32();\n            geoset.Name = state.str(80);\n        }\n        parseExtent(geoset, state);\n        var geosetAnimCount = state.int32();\n        geoset.Anims = [];\n        for (var i = 0; i < geosetAnimCount; ++i) {\n            var geosetAnim = {};\n            parseExtent(geosetAnim, state);\n            geoset.Anims.push(geosetAnim);\n        }\n        var keyword = state.keyword();\n        if (model.Version >= 900) {\n            // eslint-disable-next-line no-constant-condition\n            while (1) {\n                if (state.pos >= state.length) {\n                    throw new Error('Unexpected EOF');\n                }\n                if (keyword === 'TANG') {\n                    if (geoset.Tangents) {\n                        throw new Error('Incorrect geoset, multiple Tangents');\n                    }\n                    var len = state.int32();\n                    geoset.Tangents = state.float32Array(len * 4);\n                }\n                else if (keyword === 'SKIN') {\n                    if (geoset.SkinWeights) {\n                        throw new Error('Incorrect geoset, multiple SkinWeights');\n                    }\n                    var len = state.int32();\n                    geoset.SkinWeights = state.uint8Array(len);\n                }\n                else if (keyword === 'UVAS') {\n                    break;\n                }\n                keyword = state.keyword();\n            }\n        }\n        else if (keyword !== 'UVAS') {\n            throw new Error('Incorrect geosets format');\n        }\n        var textureChunkCount = state.int32();\n        geoset.TVertices = [];\n        for (var i = 0; i < textureChunkCount; ++i) {\n            state.expectKeyword('UVBS', 'Incorrect geosets format');\n            var textureCoordsCount = state.int32();\n            var tvertices = new Float32Array(textureCoordsCount * 2);\n            for (var j = 0; j < textureCoordsCount * 2; ++j) {\n                tvertices[j] = state.float32();\n            }\n            geoset.TVertices.push(tvertices);\n        }\n        model.Geosets.push(geoset);\n    }\n}\nfunction parseGeosetAnims(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var animStartPos = state.pos;\n        var animSize = state.int32();\n        var geosetAnim = {};\n        geosetAnim.Alpha = state.float32();\n        geosetAnim.Flags = state.int32();\n        geosetAnim.Color = new Float32Array(3);\n        for (var i = 0; i < 3; ++i) {\n            geosetAnim.Color[i] = state.float32();\n        }\n        geosetAnim.GeosetId = state.int32();\n        if (geosetAnim.GeosetId === NONE) {\n            geosetAnim.GeosetId = null;\n        }\n        while (state.pos < animStartPos + animSize) {\n            var keyword = state.keyword();\n            if (keyword === 'KGAO') {\n                geosetAnim.Alpha = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KGAC') {\n                geosetAnim.Color = state.animVector(AnimVectorType.FLOAT3);\n            }\n            else {\n                throw new Error('Incorrect GeosetAnim chunk data ' + keyword);\n            }\n        }\n        model.GeosetAnims.push(geosetAnim);\n    }\n}\nvar MODEL_NODE_NAME_LENGTH = 0x50;\nfunction parseNode(model, node, state) {\n    var startPos = state.pos;\n    var size = state.int32();\n    node.Name = state.str(MODEL_NODE_NAME_LENGTH);\n    node.ObjectId = state.int32();\n    if (node.ObjectId === NONE) {\n        node.ObjectId = null;\n    }\n    node.Parent = state.int32();\n    if (node.Parent === NONE) {\n        node.Parent = null;\n    }\n    node.Flags = state.int32();\n    while (state.pos < startPos + size) {\n        var keyword = state.keyword();\n        if (keyword === 'KGTR') {\n            node.Translation = state.animVector(AnimVectorType.FLOAT3);\n        }\n        else if (keyword === 'KGRT') {\n            node.Rotation = state.animVector(AnimVectorType.FLOAT4);\n        }\n        else if (keyword === 'KGSC') {\n            node.Scaling = state.animVector(AnimVectorType.FLOAT3);\n        }\n        else {\n            throw new Error('Incorrect node chunk data ' + keyword);\n        }\n    }\n    model.Nodes[node.ObjectId] = node;\n}\nfunction parseBones(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var bone = {};\n        parseNode(model, bone, state);\n        bone.GeosetId = state.int32();\n        if (bone.GeosetId === NONE) {\n            bone.GeosetId = null;\n        }\n        bone.GeosetAnimId = state.int32();\n        if (bone.GeosetAnimId === NONE) {\n            bone.GeosetAnimId = null;\n        }\n        model.Bones.push(bone);\n    }\n}\nfunction parseHelpers(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var helper = {};\n        parseNode(model, helper, state);\n        model.Helpers.push(helper);\n    }\n}\nvar MODEL_ATTACHMENT_PATH_LENGTH = 0x100;\nfunction parseAttachments(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var attachmentStart = state.pos;\n        var attachmentSize = state.int32();\n        var attachment = {};\n        parseNode(model, attachment, state);\n        attachment.Path = state.str(MODEL_ATTACHMENT_PATH_LENGTH);\n        state.int32(); // unknown 4-byte\n        attachment.AttachmentID = state.int32();\n        if (state.pos < attachmentStart + attachmentSize) {\n            state.expectKeyword('KATV', 'Incorrect attachment chunk data');\n            attachment.Visibility = state.animVector(AnimVectorType.FLOAT1);\n        }\n        model.Attachments.push(attachment);\n    }\n}\nfunction parsePivotPoints(model, state, size) {\n    var pointsCount = size / (4 * 3);\n    for (var i = 0; i < pointsCount; ++i) {\n        model.PivotPoints[i] = new Float32Array(3);\n        model.PivotPoints[i][0] = state.float32();\n        model.PivotPoints[i][1] = state.float32();\n        model.PivotPoints[i][2] = state.float32();\n    }\n}\nfunction parseEventObjects(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var eventObject = {};\n        parseNode(model, eventObject, state);\n        state.expectKeyword('KEVT', 'Incorrect EventObject chunk data');\n        var eventTrackCount = state.int32();\n        eventObject.EventTrack = new Uint32Array(eventTrackCount);\n        state.int32(); // unused 4-byte?\n        for (var i = 0; i < eventTrackCount; ++i) {\n            eventObject.EventTrack[i] = state.int32();\n        }\n        model.EventObjects.push(eventObject);\n    }\n}\nfunction parseCollisionShapes(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var collisionShape = {};\n        parseNode(model, collisionShape, state);\n        collisionShape.Shape = state.int32();\n        if (collisionShape.Shape === _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Box) {\n            collisionShape.Vertices = new Float32Array(6);\n        }\n        else {\n            collisionShape.Vertices = new Float32Array(3);\n        }\n        for (var i = 0; i < collisionShape.Vertices.length; ++i) {\n            collisionShape.Vertices[i] = state.float32();\n        }\n        if (collisionShape.Shape === _model__WEBPACK_IMPORTED_MODULE_0__.CollisionShapeType.Sphere) {\n            collisionShape.BoundsRadius = state.float32();\n        }\n        model.CollisionShapes.push(collisionShape);\n    }\n}\nfunction parseGlobalSequences(model, state, size) {\n    var startPos = state.pos;\n    model.GlobalSequences = [];\n    while (state.pos < startPos + size) {\n        model.GlobalSequences.push(state.int32());\n    }\n}\nvar MODEL_PARTICLE_EMITTER_PATH_LENGTH = 0x100;\nfunction parseParticleEmitters(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var emitterStart = state.pos;\n        var emitterSize = state.int32();\n        var emitter = {};\n        parseNode(model, emitter, state);\n        emitter.EmissionRate = state.float32();\n        emitter.Gravity = state.float32();\n        emitter.Longitude = state.float32();\n        emitter.Latitude = state.float32();\n        emitter.Path = state.str(MODEL_PARTICLE_EMITTER_PATH_LENGTH);\n        state.int32();\n        emitter.LifeSpan = state.float32();\n        emitter.InitVelocity = state.float32();\n        while (state.pos < emitterStart + emitterSize) {\n            var keyword = state.keyword();\n            if (keyword === 'KPEV') {\n                emitter.Visibility = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPEE') {\n                emitter.EmissionRate = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPEG') {\n                emitter.Gravity = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPLN') {\n                emitter.Longitude = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPLT') {\n                emitter.Latitude = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPEL') {\n                emitter.LifeSpan = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPES') {\n                emitter.InitVelocity = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else {\n                throw new Error('Incorrect particle emitter chunk data ' + keyword);\n            }\n        }\n        model.ParticleEmitters.push(emitter);\n    }\n}\nfunction parseParticleEmitters2(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var emitterStart = state.pos;\n        var emitterSize = state.int32();\n        var emitter = {};\n        parseNode(model, emitter, state);\n        emitter.Speed = state.float32();\n        emitter.Variation = state.float32();\n        emitter.Latitude = state.float32();\n        emitter.Gravity = state.float32();\n        emitter.LifeSpan = state.float32();\n        emitter.EmissionRate = state.float32();\n        emitter.Width = state.float32();\n        emitter.Length = state.float32();\n        emitter.FilterMode = state.int32();\n        emitter.Rows = state.int32();\n        emitter.Columns = state.int32();\n        var frameFlags = state.int32();\n        emitter.FrameFlags = 0;\n        if (frameFlags === 0 || frameFlags === 2) {\n            emitter.FrameFlags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Head;\n        }\n        if (frameFlags === 1 || frameFlags === 2) {\n            emitter.FrameFlags |= _model__WEBPACK_IMPORTED_MODULE_0__.ParticleEmitter2FramesFlags.Tail;\n        }\n        emitter.TailLength = state.float32();\n        emitter.Time = state.float32();\n        emitter.SegmentColor = [];\n        // always 3 segments\n        for (var i = 0; i < 3; ++i) {\n            emitter.SegmentColor[i] = new Float32Array(3);\n            //  rgb order, inverse from mdl\n            for (var j = 0; j < 3; ++j) {\n                emitter.SegmentColor[i][j] = state.float32();\n            }\n        }\n        emitter.Alpha = new Uint8Array(3);\n        for (var i = 0; i < 3; ++i) {\n            emitter.Alpha[i] = state.uint8();\n        }\n        emitter.ParticleScaling = new Float32Array(3);\n        for (var i = 0; i < 3; ++i) {\n            emitter.ParticleScaling[i] = state.float32();\n        }\n        for (var _i = 0, _a = ['LifeSpanUVAnim', 'DecayUVAnim', 'TailUVAnim', 'TailDecayUVAnim']; _i < _a.length; _i++) {\n            var part = _a[_i];\n            emitter[part] = new Uint32Array(3);\n            for (var i = 0; i < 3; ++i) {\n                emitter[part][i] = state.int32();\n            }\n        }\n        emitter.TextureID = state.int32();\n        if (emitter.TextureID === NONE) {\n            emitter.TextureID = null;\n        }\n        emitter.Squirt = state.int32() > 0;\n        emitter.PriorityPlane = state.int32();\n        emitter.ReplaceableId = state.int32();\n        while (state.pos < emitterStart + emitterSize) {\n            var keyword = state.keyword();\n            if (keyword === 'KP2V') {\n                emitter.Visibility = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KP2E') {\n                emitter.EmissionRate = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KP2W') {\n                emitter.Width = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KP2N') {\n                emitter.Length = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KP2S') {\n                emitter.Speed = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KP2L') {\n                emitter.Latitude = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KP2G') {\n                emitter.Gravity = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KP2R') {\n                emitter.Variation = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else {\n                throw new Error('Incorrect particle emitter2 chunk data ' + keyword);\n            }\n        }\n        model.ParticleEmitters2.push(emitter);\n    }\n}\nvar MODEL_CAMERA_NAME_LENGTH = 0x50;\nfunction parseCameras(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var cameraStart = state.pos;\n        var cameraSize = state.int32();\n        var camera = {};\n        camera.Name = state.str(MODEL_CAMERA_NAME_LENGTH);\n        camera.Position = new Float32Array(3);\n        camera.Position[0] = state.float32();\n        camera.Position[1] = state.float32();\n        camera.Position[2] = state.float32();\n        camera.FieldOfView = state.float32();\n        camera.FarClip = state.float32();\n        camera.NearClip = state.float32();\n        camera.TargetPosition = new Float32Array(3);\n        camera.TargetPosition[0] = state.float32();\n        camera.TargetPosition[1] = state.float32();\n        camera.TargetPosition[2] = state.float32();\n        while (state.pos < cameraStart + cameraSize) {\n            var keyword = state.keyword();\n            if (keyword === 'KCTR') {\n                camera.Translation = state.animVector(AnimVectorType.FLOAT3);\n            }\n            else if (keyword === 'KTTR') {\n                camera.TargetTranslation = state.animVector(AnimVectorType.FLOAT3);\n            }\n            else if (keyword === 'KCRL') {\n                camera.Rotation = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else {\n                throw new Error('Incorrect camera chunk data ' + keyword);\n            }\n        }\n        model.Cameras.push(camera);\n    }\n}\nfunction parseLights(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var lightStart = state.pos;\n        var lightSize = state.int32();\n        var light = {};\n        parseNode(model, light, state);\n        light.LightType = state.int32();\n        light.AttenuationStart = state.float32();\n        light.AttenuationEnd = state.float32();\n        light.Color = new Float32Array(3);\n        //  rgb order, inverse from mdl\n        for (var j = 0; j < 3; ++j) {\n            light.Color[j] = state.float32();\n        }\n        light.Intensity = state.float32();\n        light.AmbColor = new Float32Array(3);\n        //  rgb order, inverse from mdl\n        for (var j = 0; j < 3; ++j) {\n            light.AmbColor[j] = state.float32();\n        }\n        light.AmbIntensity = state.float32();\n        while (state.pos < lightStart + lightSize) {\n            var keyword = state.keyword();\n            if (keyword === 'KLAV') {\n                light.Visibility = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KLAC') {\n                light.Color = state.animVector(AnimVectorType.FLOAT3);\n            }\n            else if (keyword === 'KLAI') {\n                light.Intensity = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KLBC') {\n                light.AmbColor = state.animVector(AnimVectorType.FLOAT3);\n            }\n            else if (keyword === 'KLBI') {\n                light.AmbIntensity = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KLAS') {\n                light.AttenuationStart = state.animVector(AnimVectorType.INT1);\n            }\n            else if (keyword === 'KLAE') {\n                light.AttenuationEnd = state.animVector(AnimVectorType.INT1);\n            }\n            else {\n                throw new Error('Incorrect light chunk data ' + keyword);\n            }\n        }\n        model.Lights.push(light);\n    }\n}\nfunction parseTextureAnims(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var animStart = state.pos;\n        var animSize = state.int32();\n        var anim = {};\n        while (state.pos < animStart + animSize) {\n            var keyword = state.keyword();\n            if (keyword === 'KTAT') {\n                anim.Translation = state.animVector(AnimVectorType.FLOAT3);\n            }\n            else if (keyword === 'KTAR') {\n                anim.Rotation = state.animVector(AnimVectorType.FLOAT4);\n            }\n            else if (keyword === 'KTAS') {\n                anim.Scaling = state.animVector(AnimVectorType.FLOAT3);\n            }\n            else {\n                throw new Error('Incorrect light chunk data ' + keyword);\n            }\n        }\n        model.TextureAnims.push(anim);\n    }\n}\nfunction parseRibbonEmitters(model, state, size) {\n    var startPos = state.pos;\n    while (state.pos < startPos + size) {\n        var emitterStart = state.pos;\n        var emitterSize = state.int32();\n        var emitter = {};\n        parseNode(model, emitter, state);\n        emitter.HeightAbove = state.float32();\n        emitter.HeightBelow = state.float32();\n        emitter.Alpha = state.float32();\n        emitter.Color = new Float32Array(3);\n        //  rgb order, inverse from mdl\n        for (var j = 0; j < 3; ++j) {\n            emitter.Color[j] = state.float32();\n        }\n        emitter.LifeSpan = state.float32();\n        emitter.TextureSlot = state.int32();\n        emitter.EmissionRate = state.int32();\n        emitter.Rows = state.int32();\n        emitter.Columns = state.int32();\n        emitter.MaterialID = state.int32();\n        emitter.Gravity = state.float32();\n        while (state.pos < emitterStart + emitterSize) {\n            var keyword = state.keyword();\n            if (keyword === 'KRVS') {\n                emitter.Visibility = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KRHA') {\n                emitter.HeightAbove = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KRHB') {\n                emitter.HeightBelow = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KRAL') {\n                emitter.Alpha = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KRTX') {\n                emitter.TextureSlot = state.animVector(AnimVectorType.INT1);\n            }\n            else {\n                throw new Error('Incorrect ribbon emitter chunk data ' + keyword);\n            }\n        }\n        model.RibbonEmitters.push(emitter);\n    }\n}\nfunction parseFaceFX(model, state, size) {\n    if (model.Version < 900) {\n        throw new Error('Mismatched version chunk');\n    }\n    var startPos = state.pos;\n    model.FaceFX = model.FaceFX || [];\n    while (state.pos < startPos + size) {\n        var faceFX = {\n            Name: '',\n            Path: ''\n        };\n        faceFX.Name = state.str(80);\n        faceFX.Path = state.str(260);\n        model.FaceFX.push(faceFX);\n    }\n}\nfunction parseBindPose(model, state, size) {\n    if (model.Version < 900) {\n        throw new Error('Mismatched version chunk');\n    }\n    var startPos = state.pos;\n    model.BindPoses = model.BindPoses || [];\n    var len = state.int32();\n    var bindPose = {\n        Matrices: []\n    };\n    for (var i = 0; i < len; ++i) {\n        var matrix = state.float32Array(12);\n        bindPose.Matrices.push(matrix);\n    }\n    model.BindPoses.push(bindPose);\n    if (state.pos !== startPos + size) {\n        throw new Error('Mismatched BindPose data');\n    }\n}\nfunction parseParticleEmitterPopcorn(model, state, size) {\n    if (model.Version < 900) {\n        throw new Error('Mismatched version chunk');\n    }\n    var startPos = state.pos;\n    model.ParticleEmitterPopcorns = model.ParticleEmitterPopcorns || [];\n    while (state.pos < startPos + size) {\n        var emitterStart = state.pos;\n        var emitterSize = state.int32();\n        var emitter = {};\n        parseNode(model, emitter, state);\n        emitter.LifeSpan = state.float32();\n        emitter.EmissionRate = state.float32();\n        emitter.Speed = state.float32();\n        emitter.Color = state.float32Array(3);\n        emitter.Alpha = state.float32();\n        emitter.ReplaceableId = state.int32();\n        emitter.Path = state.str(260);\n        emitter.AnimVisibilityGuide = state.str(260);\n        while (state.pos < emitterStart + emitterSize) {\n            var keyword = state.keyword();\n            if (keyword === 'KPPA') {\n                emitter.Alpha = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPPC') {\n                emitter.Color = state.animVector(AnimVectorType.FLOAT3);\n            }\n            else if (keyword === 'KPPE') {\n                emitter.EmissionRate = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPPL') {\n                emitter.LifeSpan = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPPS') {\n                emitter.Speed = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else if (keyword === 'KPPV') {\n                emitter.Visibility = state.animVector(AnimVectorType.FLOAT1);\n            }\n            else {\n                throw new Error('Incorrect particle emitter popcorn chunk data ' + keyword);\n            }\n        }\n        model.ParticleEmitterPopcorns.push(emitter);\n    }\n}\nvar parsers = {\n    VERS: parseVersion,\n    MODL: parseModelInfo,\n    SEQS: parseSequences,\n    MTLS: parseMaterials,\n    TEXS: parseTextures,\n    GEOS: parseGeosets,\n    GEOA: parseGeosetAnims,\n    BONE: parseBones,\n    HELP: parseHelpers,\n    ATCH: parseAttachments,\n    PIVT: parsePivotPoints,\n    EVTS: parseEventObjects,\n    CLID: parseCollisionShapes,\n    GLBS: parseGlobalSequences,\n    PREM: parseParticleEmitters,\n    PRE2: parseParticleEmitters2,\n    CAMS: parseCameras,\n    LITE: parseLights,\n    TXAN: parseTextureAnims,\n    RIBB: parseRibbonEmitters,\n    FAFX: parseFaceFX,\n    BPOS: parseBindPose,\n    CORN: parseParticleEmitterPopcorn\n};\nfunction parse(arrayBuffer) {\n    var state = new State(arrayBuffer);\n    if (state.keyword() !== 'MDLX') {\n        throw new Error('Not a mdx model');\n    }\n    var model = {\n        // default\n        Version: 800,\n        Info: {\n            Name: '',\n            MinimumExtent: null,\n            MaximumExtent: null,\n            BoundsRadius: 0,\n            BlendTime: 150\n        },\n        Sequences: [],\n        GlobalSequences: [],\n        Textures: [],\n        Materials: [],\n        TextureAnims: [],\n        Geosets: [],\n        GeosetAnims: [],\n        Bones: [],\n        Helpers: [],\n        Attachments: [],\n        EventObjects: [],\n        ParticleEmitters: [],\n        ParticleEmitters2: [],\n        Cameras: [],\n        Lights: [],\n        RibbonEmitters: [],\n        CollisionShapes: [],\n        PivotPoints: [],\n        Nodes: []\n    };\n    while (state.pos < state.length) {\n        var keyword = state.keyword();\n        var size = state.int32();\n        if (keyword in parsers) {\n            parsers[keyword](model, state, size);\n        }\n        else {\n            // throw new Error('Unknown group ' + keyword);\n            state.pos += size;\n        }\n    }\n    for (var i = 0; i < model.Nodes.length; ++i) {\n        if (model.Nodes[i] && model.PivotPoints[i]) {\n            model.Nodes[i].PivotPoint = model.PivotPoints[i];\n        }\n    }\n    model.Info.NumGeosets = model.Geosets.length;\n    model.Info.NumGeosetAnims = model.GeosetAnims.length;\n    model.Info.NumBones = model.Bones.length;\n    model.Info.NumLights = model.Lights.length;\n    model.Info.NumAttachments = model.Attachments.length;\n    model.Info.NumEvents = model.EventObjects.length;\n    model.Info.NumParticleEmitters = model.ParticleEmitters.length;\n    model.Info.NumParticleEmitters2 = model.ParticleEmitters2.length;\n    model.Info.NumRibbonEmitters = model.RibbonEmitters.length;\n    return model;\n}\n\n\n//# sourceURL=webpack://war3-model/./mdx/parse.ts?");

/***/ }),

/***/ "./model.ts":
/*!******************!*\
  !*** ./model.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionShapeType: () => (/* binding */ CollisionShapeType),\n/* harmony export */   FilterMode: () => (/* binding */ FilterMode),\n/* harmony export */   GeosetAnimFlags: () => (/* binding */ GeosetAnimFlags),\n/* harmony export */   LayerShading: () => (/* binding */ LayerShading),\n/* harmony export */   LightType: () => (/* binding */ LightType),\n/* harmony export */   LineType: () => (/* binding */ LineType),\n/* harmony export */   MaterialRenderMode: () => (/* binding */ MaterialRenderMode),\n/* harmony export */   NodeFlags: () => (/* binding */ NodeFlags),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   ParticleEmitter2FilterMode: () => (/* binding */ ParticleEmitter2FilterMode),\n/* harmony export */   ParticleEmitter2Flags: () => (/* binding */ ParticleEmitter2Flags),\n/* harmony export */   ParticleEmitter2FramesFlags: () => (/* binding */ ParticleEmitter2FramesFlags),\n/* harmony export */   ParticleEmitterFlags: () => (/* binding */ ParticleEmitterFlags),\n/* harmony export */   ParticleEmitterPopcornFlags: () => (/* binding */ ParticleEmitterPopcornFlags),\n/* harmony export */   TextureFlags: () => (/* binding */ TextureFlags)\n/* harmony export */ });\nvar TextureFlags;\n(function (TextureFlags) {\n    TextureFlags[TextureFlags[\"WrapWidth\"] = 1] = \"WrapWidth\";\n    TextureFlags[TextureFlags[\"WrapHeight\"] = 2] = \"WrapHeight\";\n})(TextureFlags || (TextureFlags = {}));\nvar FilterMode;\n(function (FilterMode) {\n    FilterMode[FilterMode[\"None\"] = 0] = \"None\";\n    FilterMode[FilterMode[\"Transparent\"] = 1] = \"Transparent\";\n    FilterMode[FilterMode[\"Blend\"] = 2] = \"Blend\";\n    FilterMode[FilterMode[\"Additive\"] = 3] = \"Additive\";\n    FilterMode[FilterMode[\"AddAlpha\"] = 4] = \"AddAlpha\";\n    FilterMode[FilterMode[\"Modulate\"] = 5] = \"Modulate\";\n    FilterMode[FilterMode[\"Modulate2x\"] = 6] = \"Modulate2x\";\n})(FilterMode || (FilterMode = {}));\nvar LineType;\n(function (LineType) {\n    LineType[LineType[\"DontInterp\"] = 0] = \"DontInterp\";\n    LineType[LineType[\"Linear\"] = 1] = \"Linear\";\n    LineType[LineType[\"Hermite\"] = 2] = \"Hermite\";\n    LineType[LineType[\"Bezier\"] = 3] = \"Bezier\";\n})(LineType || (LineType = {}));\nvar LayerShading;\n(function (LayerShading) {\n    LayerShading[LayerShading[\"Unshaded\"] = 1] = \"Unshaded\";\n    LayerShading[LayerShading[\"SphereEnvMap\"] = 2] = \"SphereEnvMap\";\n    LayerShading[LayerShading[\"TwoSided\"] = 16] = \"TwoSided\";\n    LayerShading[LayerShading[\"Unfogged\"] = 32] = \"Unfogged\";\n    LayerShading[LayerShading[\"NoDepthTest\"] = 64] = \"NoDepthTest\";\n    LayerShading[LayerShading[\"NoDepthSet\"] = 128] = \"NoDepthSet\";\n})(LayerShading || (LayerShading = {}));\nvar MaterialRenderMode;\n(function (MaterialRenderMode) {\n    MaterialRenderMode[MaterialRenderMode[\"ConstantColor\"] = 1] = \"ConstantColor\";\n    MaterialRenderMode[MaterialRenderMode[\"SortPrimsFarZ\"] = 16] = \"SortPrimsFarZ\";\n    MaterialRenderMode[MaterialRenderMode[\"FullResolution\"] = 32] = \"FullResolution\";\n})(MaterialRenderMode || (MaterialRenderMode = {}));\nvar GeosetAnimFlags;\n(function (GeosetAnimFlags) {\n    GeosetAnimFlags[GeosetAnimFlags[\"DropShadow\"] = 1] = \"DropShadow\";\n    GeosetAnimFlags[GeosetAnimFlags[\"Color\"] = 2] = \"Color\";\n})(GeosetAnimFlags || (GeosetAnimFlags = {}));\nvar NodeFlags;\n(function (NodeFlags) {\n    NodeFlags[NodeFlags[\"DontInheritTranslation\"] = 1] = \"DontInheritTranslation\";\n    NodeFlags[NodeFlags[\"DontInheritRotation\"] = 2] = \"DontInheritRotation\";\n    NodeFlags[NodeFlags[\"DontInheritScaling\"] = 4] = \"DontInheritScaling\";\n    NodeFlags[NodeFlags[\"Billboarded\"] = 8] = \"Billboarded\";\n    NodeFlags[NodeFlags[\"BillboardedLockX\"] = 16] = \"BillboardedLockX\";\n    NodeFlags[NodeFlags[\"BillboardedLockY\"] = 32] = \"BillboardedLockY\";\n    NodeFlags[NodeFlags[\"BillboardedLockZ\"] = 64] = \"BillboardedLockZ\";\n    NodeFlags[NodeFlags[\"CameraAnchored\"] = 128] = \"CameraAnchored\";\n})(NodeFlags || (NodeFlags = {}));\nvar NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Helper\"] = 0] = \"Helper\";\n    NodeType[NodeType[\"Bone\"] = 256] = \"Bone\";\n    NodeType[NodeType[\"Light\"] = 512] = \"Light\";\n    NodeType[NodeType[\"EventObject\"] = 1024] = \"EventObject\";\n    NodeType[NodeType[\"Attachment\"] = 2048] = \"Attachment\";\n    NodeType[NodeType[\"ParticleEmitter\"] = 4096] = \"ParticleEmitter\";\n    NodeType[NodeType[\"CollisionShape\"] = 8192] = \"CollisionShape\";\n    NodeType[NodeType[\"RibbonEmitter\"] = 16384] = \"RibbonEmitter\";\n})(NodeType || (NodeType = {}));\nvar CollisionShapeType;\n(function (CollisionShapeType) {\n    CollisionShapeType[CollisionShapeType[\"Box\"] = 0] = \"Box\";\n    CollisionShapeType[CollisionShapeType[\"Sphere\"] = 2] = \"Sphere\";\n})(CollisionShapeType || (CollisionShapeType = {}));\nvar ParticleEmitterFlags;\n(function (ParticleEmitterFlags) {\n    ParticleEmitterFlags[ParticleEmitterFlags[\"EmitterUsesMDL\"] = 32768] = \"EmitterUsesMDL\";\n    ParticleEmitterFlags[ParticleEmitterFlags[\"EmitterUsesTGA\"] = 65536] = \"EmitterUsesTGA\";\n})(ParticleEmitterFlags || (ParticleEmitterFlags = {}));\nvar ParticleEmitter2Flags;\n(function (ParticleEmitter2Flags) {\n    ParticleEmitter2Flags[ParticleEmitter2Flags[\"Unshaded\"] = 32768] = \"Unshaded\";\n    ParticleEmitter2Flags[ParticleEmitter2Flags[\"SortPrimsFarZ\"] = 65536] = \"SortPrimsFarZ\";\n    ParticleEmitter2Flags[ParticleEmitter2Flags[\"LineEmitter\"] = 131072] = \"LineEmitter\";\n    ParticleEmitter2Flags[ParticleEmitter2Flags[\"Unfogged\"] = 262144] = \"Unfogged\";\n    ParticleEmitter2Flags[ParticleEmitter2Flags[\"ModelSpace\"] = 524288] = \"ModelSpace\";\n    ParticleEmitter2Flags[ParticleEmitter2Flags[\"XYQuad\"] = 1048576] = \"XYQuad\";\n})(ParticleEmitter2Flags || (ParticleEmitter2Flags = {}));\nvar ParticleEmitter2FilterMode;\n(function (ParticleEmitter2FilterMode) {\n    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode[\"Blend\"] = 0] = \"Blend\";\n    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode[\"Additive\"] = 1] = \"Additive\";\n    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode[\"Modulate\"] = 2] = \"Modulate\";\n    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode[\"Modulate2x\"] = 3] = \"Modulate2x\";\n    ParticleEmitter2FilterMode[ParticleEmitter2FilterMode[\"AlphaKey\"] = 4] = \"AlphaKey\";\n})(ParticleEmitter2FilterMode || (ParticleEmitter2FilterMode = {}));\n// Not actually mapped to mdx flags (0: Head, 1: Tail, 2: Both)\nvar ParticleEmitter2FramesFlags;\n(function (ParticleEmitter2FramesFlags) {\n    ParticleEmitter2FramesFlags[ParticleEmitter2FramesFlags[\"Head\"] = 1] = \"Head\";\n    ParticleEmitter2FramesFlags[ParticleEmitter2FramesFlags[\"Tail\"] = 2] = \"Tail\";\n})(ParticleEmitter2FramesFlags || (ParticleEmitter2FramesFlags = {}));\nvar LightType;\n(function (LightType) {\n    LightType[LightType[\"Omnidirectional\"] = 0] = \"Omnidirectional\";\n    LightType[LightType[\"Directional\"] = 1] = \"Directional\";\n    LightType[LightType[\"Ambient\"] = 2] = \"Ambient\";\n})(LightType || (LightType = {}));\n/* Since Version: 900 */\nvar ParticleEmitterPopcornFlags;\n(function (ParticleEmitterPopcornFlags) {\n    ParticleEmitterPopcornFlags[ParticleEmitterPopcornFlags[\"Unshaded\"] = 32768] = \"Unshaded\";\n    ParticleEmitterPopcornFlags[ParticleEmitterPopcornFlags[\"SortPrimsFarZ\"] = 65536] = \"SortPrimsFarZ\";\n    ParticleEmitterPopcornFlags[ParticleEmitterPopcornFlags[\"Unfogged\"] = 262144] = \"Unfogged\";\n})(ParticleEmitterPopcornFlags || (ParticleEmitterPopcornFlags = {}));\n\n\n//# sourceURL=webpack://war3-model/./model.ts?");

/***/ }),

/***/ "./renderer/util.ts":
/*!**************************!*\
  !*** ./renderer/util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LAYER_TEXTURE_ID_MAP: () => (/* binding */ LAYER_TEXTURE_ID_MAP),\n/* harmony export */   LAYER_TEXTURE_NAME_MAP: () => (/* binding */ LAYER_TEXTURE_NAME_MAP),\n/* harmony export */   degToRad: () => (/* binding */ degToRad),\n/* harmony export */   getShader: () => (/* binding */ getShader),\n/* harmony export */   isWebGL2: () => (/* binding */ isWebGL2),\n/* harmony export */   mat4fromRotationOrigin: () => (/* binding */ mat4fromRotationOrigin),\n/* harmony export */   rand: () => (/* binding */ rand),\n/* harmony export */   vec3RotateZ: () => (/* binding */ vec3RotateZ)\n/* harmony export */ });\nfunction mat4fromRotationOrigin(out, rotation, origin) {\n    var x = rotation[0], y = rotation[1], z = rotation[2], w = rotation[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, ox = origin[0], oy = origin[1], oz = origin[2];\n    out[0] = (1 - (yy + zz));\n    out[1] = (xy + wz);\n    out[2] = (xz - wy);\n    out[3] = 0;\n    out[4] = (xy - wz);\n    out[5] = (1 - (xx + zz));\n    out[6] = (yz + wx);\n    out[7] = 0;\n    out[8] = (xz + wy);\n    out[9] = (yz - wx);\n    out[10] = (1 - (xx + yy));\n    out[11] = 0;\n    out[12] = ox - (out[0] * ox + out[4] * oy + out[8] * oz);\n    out[13] = oy - (out[1] * ox + out[5] * oy + out[9] * oz);\n    out[14] = oz - (out[2] * ox + out[6] * oy + out[10] * oz);\n    out[15] = 1;\n    return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction vec3RotateZ(out, a, c) {\n    out[0] = a[0] * Math.cos(c) - a[1] * Math.sin(c);\n    out[1] = a[0] * Math.sin(c) + a[1] * Math.cos(c);\n    out[2] = a[2];\n    return out;\n}\nfunction rand(from, to) {\n    return from + Math.random() * (to - from);\n}\nfunction degToRad(angle) {\n    return angle * Math.PI / 180;\n}\nfunction getShader(gl, source, type) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        alert(gl.getShaderInfoLog(shader));\n        return null;\n    }\n    return shader;\n}\nfunction isWebGL2(gl) {\n    return gl instanceof WebGL2RenderingContext;\n}\nvar LAYER_TEXTURE_NAME_MAP = {\n    'TextureID': 0,\n    'NormalTextureID': 1,\n    'ORMTextureID': 2,\n    'EmissiveTextureID': 3,\n    'TeamColorTextureID': 4,\n    'ReflectionsTextureID': 5\n};\nvar LAYER_TEXTURE_ID_MAP = [\n    'TextureID',\n    'NormalTextureID',\n    'ORMTextureID',\n    'EmissiveTextureID',\n    'TeamColorTextureID',\n    'ReflectionsTextureID'\n];\n\n\n//# sourceURL=webpack://war3-model/./renderer/util.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./docs/optframes/optframes.ts");
/******/ 	
/******/ })()
;